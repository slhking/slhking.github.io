[{"title":"链表的学习","date":"2022-04-22T23:32:25.000Z","path":"2022/04/23/链表的学习/","text":"1. 什么是链表？​ 链表，别名链式存储结构或者单链表，用于存储逻辑关系为“一对一”的数据。链表不限制数据的物理存储状态，使用链表存储的数据元素，其物理存储位置是随机的。 2. 链表的节点​ 链表中每个数据的存储都由以下两部分组成： 数据元素本身，其所在的区域成为数据域； 指向直接后继元素的指针，所在的区域称为指针域； 1234567typedef struct List *pList;struct List&#123; int data; // 数据域 struct List *next; // 指针域&#125;; ​ 一个完整的链表需要以下及部分组成： 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的为止； 节点：链表中的节点又细分为头节点、首元节点： 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题； 首元节点：由于头节点的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据的节点的一个称谓，没有实际意义； 其它节点； 注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。 3. 链表的主要操作3.1 创建一个无头节点的链表​ 创建一个链表需要做如下工作： 声明一个头指针，如果有必要，可以声明一个头节点； 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系； 1 3.2 求链表长度123456789101112int GetListLength(pList npList)&#123; int i = 0; pList p = npList; while(p) &#123; p = p-&gt;next; i++; &#125; return i;&#125; 3.3 查找链表节点​ 按序号查找: 1234567891011121314pList FindListByNum(int k, pList npList)&#123; pList p = npList; int i = 1; while(p!=NULL &amp;&amp; i&lt;k) &#123; p = p-&gt;next; i++; &#125; if(i==k) return p; return NULL;&#125; ​ 按值查找: 12345678910pList FineListByValue(int value, pList npList)&#123; pList p = npList; while(p!=null &amp;&amp; p-&gt;data!=value) &#123; p = p-&gt;next; &#125; return p;&#125; 3.4 在链表中插入节点","tags":[{"name":"C语言","slug":"C语言","permalink":"http://slhking.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单片机","slug":"单片机","permalink":"http://slhking.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"嵌入式Linux学习疑惑随手记","date":"2022-04-22T14:52:34.000Z","path":"2022/04/22/嵌入式Linux学习疑惑随手记/","text":"1. 嵌入式Linux中App开发人员是如何得知可以操控哪些底层硬件的？ 系统会自动挂载，如果没有自动挂载就需要去手动执行挂载命令；我们怎么直到是否自动挂载呢？在终端执行： 1cat /proc/mounts 查看系统设备： 1ls /dev/* -l # 查看所有的设备，包括其主设备号和次设备号 在Linux内核里面，有两类驱动程序：字符(char)设备驱动程序和块(block)设备驱动程序。 图中，c代表字符设备驱动程序， 89就是设备的主设备号，0&#x2F;1&#x2F;2就是设备的次设备号。设备节点对应哪一个设备驱动程序通过主设备号来确定，而次设备号则是决定该设备节点对应的是设备驱动程序中对应的哪一个硬件。 2. Linux中对文件的操作 打开文件：open 需要包含的头文件： 123#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; 可以调用的API： 12int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode); 当成功打开一个文件后，open的返回值会是这个文件的描述符句柄，如果打开失败，那么它的返回值就是-1。 参数flags的范围： flags 涵义 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 O_APPEND 以附件的方式打开文件，在对该文件进行写的时候，会偏移到文件的末尾开始写 O_ASYNC Enable signal-driven I&#x2F;O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor. This feature is available only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. O_CLOEXEC Enable the close-on-exec flag for the new file descriptor O_CREAT If pathname does not exist, create it as a regular file.这个Flags会用到mode O_DIRECT Try to minimize cache effects of the I&#x2F;O to and from this file. O_DIRECTORY If pathname is not a directory, cause the open to fail O_DSYNC Write operations on the file will complete according to the requirements of synchronized I&#x2F;O data integrity completion. O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() fails with the error EEXIST. O_LARGEFILE Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened. O_NOATIME Do not update the file last access time (st_atime in the inode) when the file is read(2). O_NOCTTY If pathname refers to a terminal device—see tty(4)—it will not become the process’s controlling terminal even if the process does not have one. O_NOFOLLOW If pathname is a symbolic link, then the open fails, with the error ELOOP. O_NONBLOCK&#x2F;O_NDELAY When possible, the file is opened in nonblocking mode. O_PATH Obtain a file descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to perform operations that act purely at the file descriptor level. O_SYNC Write operations on the file will complete according to the requirements of synchronized I&#x2F;O file integrity completion(by contrast with the synchronized I&#x2F;O data integrity completion provided by O_DSYNC.) O_TMPFILE Create an unnamed temporary regular file. O_TRUNC If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0. If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored. Otherwise, the effect of O_TRUNC is unspecified. 当flags支持O_CREAT时，可以选择的mode有： mode 作用 S_IRWXU user (file owner) has read, write, and execute permission S_IRUSR user has read permission S_IWUSR user has write permission S_IXUSR user has execute permission S_IRWXG group has read, write, and execute permission S_IRGRP group has read permission S_IWGRP group has write permission S_IXGRP group has execute permission S_IRWXO others have read, write, and execute permission S_IROTH others have read permission S_IWOTH others have write permission S_IXOTH others have execute permission S_ISUID set-user-ID bit S_ISGID set-group-ID bit S_ISVTX sticky bit 其中，user&#x2F;group&#x2F;others指代的什么？","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"},{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"ROS的快速体验","date":"2022-04-22T09:36:56.000Z","path":"2022/04/22/ROS的快速体验/","text":"​ 本文参考的是赵虚左老师的博客和视频。主要目的是记录一下快速使用ROS输出Hello World!这个信息的步骤。 1. 概述​ ROS设计的编程语言主要是C++和python，使用哪一门语言进行开发取决于我们熟悉使用哪一门语言。 ​ 实现输出Hello World!的步骤分为如下几步： 创建一个工作空间； 在工作空间中创建一个功能包； 编辑源文件； 编辑配置文件； 编译并执行； 2. 创建和编译2.1 创建工作空间并初始化123mkdir -p 自定义空间名称/srccd 自定义空间名称catkin_make 需要注意的是，使用mkdir创建工作空间的时候，后面必须要有/src；初始化的时候，必须是在创建好的工作空间内进行初始化。 2.2 进入src创建ros功能包并添加依赖12cd srccatkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 123roscpp: C++的依赖包rospy: python的依赖包std_msgs: 标准输入输出的依赖包 2.3 使用C++实现输出Hello World2.3.1 ROS功能包内容 进入刚才创建的ros功能包： 1cd ros功能包 可以看到这里面也有一个src文件夹，我们需要将当前ros功能包要实现的功能的源代码文件放在这个文件夹下，头文件放在ros功能包中的include文件夹下。需要注意区分工作空间下的src文件夹和ros功能包中的src文件夹。 2.3.2 创建和编辑节点源文件 进入ros功能包中的src文件夹新建源文件 12cd srcgedit hello.cpp 使用gedit新建并打开hello.cpp，如果不是在vmware或者vxwork中而是使用ssh连接虚拟机的话，需要将gedit换做vim。 编辑hello.cpp 12345678910111213#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123; //执行 ros 节点初始化 ros::init(argc,argv,&quot;hello&quot;); //创建 ros 节点句柄(非必须) ros::NodeHandle n; //控制台输出 hello world ROS_INFO(&quot;hello world!&quot;); return 0;&#125; 我们要使用ros的库API，需要包含它的头文件。在main函数中，一个简单的ros节点创建和信息输出总结为如下几步： 使用ros-&gt;init接口初始化节点，第三个参数是节点名称； 使用ros-&gt;NodeHandle 创建当前ros节点的句柄； 调用ros标准信息输出接口ROS输出信息； 编辑好源代码之后保存退出编辑； 2.3.3 编译配置文件 编辑ros功能包中的配置文件CMakelist.txt 12cd ~/工作空间/src/ros功能包gedit CMakelist.txt 找到默认被注释掉的add_executable和target_link_libraries，默认分别是在136行和149行： 将他们按照下面的格式修改： 123456add_executable(步骤3的源文件名 src/步骤3的源文件名.cpp)target_link_libraries(步骤3的源文件名 $&#123;catkin_LIBRARIES&#125;) 然后保存退出编辑。 2.3.4 编译功能包 进入工作空间根目录编译 12cd ~/Desktop/工作空间catkin_make 如果提示编译失败： 则根据提示去修改，比如我们这里最初提示在配置文件CMakelist.txt中没有找到hello_node.cpp，也就是我们的配置文件没有修改正确，那我们又去ros功能包中修改CMakelist.txt文件： 再重新回到工作空间编译，编译成功会有如下提示： 3. 执行​ 需要打开两个终端： 在终端1中启动ROS： 1roscore 在终端2中启动编译出来的ros节点 123cd ~/工作空间source ./devel/setup.bashrosrun 包名 C++节点 当我们执行后看到了打印信息则证明我们的ROS环境搭建基本没有问题。 source ~/工作空间/devel/setup.bash可以添加进.bashrc文件，使用上更方便，这一步是配置环境变量。","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"ROS环境搭建","date":"2022-04-22T08:42:02.000Z","path":"2022/04/22/ROS环境搭建/","text":"​ 本文参考的是赵虚左老师的博客以及视频。 1. 安装虚拟机​ 需要下载的软件：VxWork或者vmware以及ubuntu虚拟机镜像，ubuntu镜像学习使用的版本是20.04。虚拟机的安装步骤比较简单，网上有很多参考，这里略过不写。 2. 安装ROS2.1 配置ubuntu的软件和更新 需要保证途中的复选框都勾选上，且下载自那个地方要选择一个国内的服务器。 2.2 设置安装源 默认的安装源： 1sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 国内清华的安装源： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 国内中科大的安装源： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2.3 设置ROS的key1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 2.4 更新源sudo apt update 2.5 安装ROSsudo apt install ros-noetic-desktop-full 这个安装过程受限于网络环境和网络速度，过程可能比较漫长，而且过程中还可能会报错，如果报错了就重新执行这条命令，它会从错误的地方开始继续安装，不会从头安装。需要耐心等待。 2.6 配置环境变量12echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 3. ROS依赖安装 首先安装构建依赖的相关工具： sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 初始化rosdep 12sudo rosdep initrosdep update 如果一切顺利的话： 但是一般都会在rosdep update这一步出错，在这一步，如果能翻墙的话可以翻墙后重复执行一直到成功，如果不能翻墙，则参考赵虚左老师的方法：http://www.autolabor.com.cn/book/ROSTutorials 4. 验证环境 开启三个终端（ctrl+shift+t可以打开一个终端）； 终端1输入指令：roscore；开启ROS核心控制器 终端2输入指令：rosrun turtlesim turtlesim_node；开启乌龟控制图形界面 终端3输入指令：rosrun turtlesim turtle_teleop_key；开启获取键盘鼠标的ros程序 将鼠标光标放置终端3窗口，然后按下键盘的上下左右键，如果能控制乌龟则说明ROS环境搭建完成；","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"VS1053B开发——使用STM32CubeIDE新建工程","date":"2021-04-11T15:46:42.000Z","path":"2021/04/11/VS1053B开发——使用STM32CubeIDE新建工程/","text":"​ 本篇是记录的是使用STM32CubeIDE新建一个开发VS1053B芯片的工程，包括了对基本外设的配置和FATFS系统以及freeRTOS系统的添加。 我的VS1053B开发系列所有文章 VS1053B开发——手册学习笔记 VS1053B开发——使用STM32CubeIDE新建工程。 源码地址 新建工程源码：VS1053B_Prj_NewProject 使用命令 git clone https://gitee.com/slhking/vs1053-b_-prj_-new-project.git将工程下载到本地。 1. 开发环境 硬件环境：STM32F103 + VS1053B + 咪头 + 运放喇叭 软件环境：STM32CubeIDE 串口调试工具：Mobaxterm 其他工具：需要SD卡，因为使用了FATFS来读取SD卡内的MP3文件 预先使用这些，后面使用到了再来添加 2. 硬件框图3. 程序流程图4. 建立工程 使用HAL库； MCU主频72MHz； 使用freeFTOS; 使用FATFS； 4.1 使用STM32CubeIDE创建基础工程 第一步，创建工程文件夹：在保存项目工程的路径下新建项目文件夹，我的就取名叫VS1053B_Prj，如图： 第二步，打开STM32CubeIDE，选择工作区路径，我们就选择在项目文件夹下，然后点击Launch，如图: 第三步，新建STM32工程，如图： 第四步，选择芯片，首先搜索我们使用的芯片，然后根据封装选择具体是哪一个，随后点击Next，如图： 第五步，设置工程名称及模板，首先给工程取一个名字，我们就和项目名称一样，然后操作条件即工程模板就使用默认参数，随后点击Finish，在弹出来的框体中选择Yes，如图： 第六步，初始化系统时钟，我习惯上先初始化系统时钟，选择外部晶振，随后去配置PLL时钟源来自HSE，系统时钟源来自PLLCLK，主频设置为72MHz，然后敲击回车让STM32CubeMX自动得到时钟方案，如图： 第七步，设置Debug，默认是不使能Debug功能，但是我们开发过程中肯定会使用到Debug功能的，因而这里随意选择一种都可以，如图： 第八步，配置SDIO，选择SD 4 bits Wide Bus，然后其他参数默认就好，如图： 第九步，配置FATFS。我们需要FATFS文件系统来读取SD卡内的MP3文件，所以需要添加FATFS。模式选择SD Card，参数使用默认参数，如图： 第十步，配置MCU和VS1053B之间通信使用的SPI，我们首先查看原理图，使用的是哪几个引脚以及使用的是哪一个SPI，原理图如图： ​ 可以看到，使用的是MCU的SPI2，引脚是: 引脚号 SPI 线 功能描述 PB12 SPI2_CS0 硬件片选 PB13 SPI2_SCK SPI时钟线 PB14 SPI2_MISO SPI主机接收从机输出 PB15 SPI2_MOSI SPI主机输出从机输入 所以我们来配置SPI2的参数，首先选择全双工主机模式，然后是硬件片选，随后是分频倍数，因为在上一篇我们知道，在配置VS1053的时候VS1053B的SPI频率在外部晶振是12.288MHz时最大是6MHz，读写RAM的时候最大是9MHz，所以我们在初始化的时候选择8分频。即36MHz&#x2F;8&#x3D;4.5MHz，其他的先暂时使用默认值，如图： - 第十一步，配置USART1，原理图上使用的引脚是PA9和PA10，如图： 所以我们在STM32CubeMX里来配置USART1，首先选择USART1，模式选择异步通信，波特率设置为115200，数据位是8bit，没有校验位，1bit的停止位，全双工模式，如图： - 第十二步，配置freeFTOS，接口那里选择V1或者V2都可以，我选择的是V2（对freeRTOS的了解还不深，解释不了为什么，到后面学习freeRTOS后再来天坑），其他参数使用默认值，如图： - 第十三步，设置工程参数，主要是设置一个给配置的外设添加对应的.c和.h文件，如图所示： - 第十四步，保存STM32CubeMX的配置，键盘按Ctrl + S，然后生成代码，然后在过程中弹出来的窗口都选择Yes就好了，如图： 4.2 观察生成的工程​ STM32CubeIDE下使用STM32CubeMX生成的代码，其结构和IDE各窗口如图所示： 因为使用了STM32CubeMX，而且在可见的未来，我们后续还会使用CubeMX来配置某些外设，因而在编辑代码的时候就要遵循一个规则，即在USER CODE BEGIN和USER CODE END之间添加我们想要添加的代码，这样是为了避免下次使用CubeMX配置别的外设的时候，重新生成代码时，我们在这个区域外添加的代码被覆盖消失掉，如图： 4.3 重定位printf()函数​ 在main.c中的 /* USER CODE BEGIN 0 */ /* USER CODE END 0 */ 中间添加如下代码： #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&huart1, (uint8_t*)&ch, 1, HAL_MAX_DELAY); return ch; } #endif 如图所示： 添加了这段代码之后，就可以调用printf()函数进行调试打印了。 4.4 编译和清理&amp;emsp;&amp;emsp;编译可以选择菜单栏的那个锤子图标，如图： 也可以右键工程，选择编译： 然后来查看编译结果： 4.5 调试​ 这一步的前提是，ST-Link已经连上了开发板，并且开发板已经上电。 4.5.1 首先设置调试配置参数&amp;emsp;&amp;emsp;可以选择菜单栏上的小甲虫边上的向下箭头选择调试配置，如图： 也可以选择右键工程，选择Debug，然后选择调试配置，如图： 然后在弹出的这个窗口进行如下配置之后点击Apply和OK，然后就开始使用ST-Link连接芯片调试： 在过程中弹出的这个窗口可以这样选择： 这样就开始我们的调试了，至于打断点、单步调试或其他调试手段就不一一介绍了，不会的可以去百度看看。 ### 4.5.2 初体验 ​ 这一步的前提是，在调试的前提下，再把开发板上的USB口使用USB线和电脑连接起来。我们在main()函数中的USART1初始化之后，调用一个printf()看下效果，调用printf()函数还要添加一个头文件stdio.h添加代码如图： 然后编译调试，且打开串口调试工具查看： 5. 结尾​ 本篇只是新建了一个工程，还没有正式开始对VS1053B的驱动开发。下面一章就会正式开始编写VS1053B的SPI通信部分了。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"STM32","slug":"STM32","permalink":"http://slhking.github.io/tags/STM32/"},{"name":"VS1053","slug":"VS1053","permalink":"http://slhking.github.io/tags/VS1053/"}]},{"title":"VS1053B开发——手册学习笔记","date":"2021-04-11T03:52:13.000Z","path":"2021/04/11/VS1053B开发——手册学习笔记/","text":"​ 本篇是记录学习VS1053B这个芯片的手册的一些心得和笔记。 我的VS1053B开发系列所有文章 VS1053B开发——手册学习笔记 VS1053B开发——使用STM32CubeIDE新建工程。 1. VS1053是什么 这一段是翻译的官方手册 VS1053b 是单片Ogg Vorbis&#x2F;MP3&#x2F;AAC&#x2F;WMA&#x2F;MIDI音频解码器，及IMA ADPCM 编码器和用户加载的Ogg Vorbis编码器。它包含了一个高性能、有专利的低功耗DSP 处理器内核VS_DSP4、工作数据存储器、供用户应用程序和任何固化解码器一起运行的16 KiB 指令RAM 及0.5KiB 多的数据RAM、串行的控制和输入数据接口、最多8 个可用的通用I&#x2F;O引脚、一个UART、并有一个优质的可变采样率立体声ADC（“咪”、“线路”、“线路+咪”或“线路*2”）和立体声DAC、和跟随的一个耳机功放及一个公共电压缓冲器。 VS1053B通过一个串行输入总线接收它的位元流，而且它是作为一个从机来监听的。输入的数据流被解码成数字信号发给一个18bit的DAC。解码是由一个串行控制总线控制的。除了基本的解码之外，它还可以添加具有特殊功能的应用到用户RAM存储区，比如DSP效果。2. VS1053具有哪些特征 这一段是翻译的官方手册 序号 特征 序号 特征 序号 特征 1 Ogg Vorbis 解码；MPEG 1 &amp; 2 音频阶层III (CBR +VBR +ABR)；阶层 I 和 II 可选；MPEG4&#x2F;2 AAC‐LC(+PNS)，HE‐AAC V2 (级别3) (SBR + PS)；WMA 4.0&#x2F;4.1&#x2F;7&#x2F;8&#x2F;9 所有特性注1 （profiles）(5‐384kbps)；WAV (PCM + IMA ADPCM)；通用 MIDI 1 &#x2F; SP‐MIDI 格式0 的文件 9 内建PLL 时钟乘法器 17 供用户代码和数据使用的片内RAM 2 用软件插件进行Ogg Vorbis 编码（2007 第四季可用） 10 低功耗运作 18 用于控制和数据的串行接口 3 “咪&#x2F;线路”的输入信号可实现IMA ADPCM 编码 (立体声) 11 芯片内建高质量和通道间无相位误差的立体声DAC 19 可以作为从模式的辅助处理器使用 4 支持MP3 和WAV 的数据流 12 过零交叉注3（Zero‐cross）侦测和平滑的音量调整 20 特殊应用可使用SPI FLASH 存储器引导 5 EarSpeaker 空间效果注 2 处理 13 立体声耳机驱动器可以驱动一个30Ω的负载 21 可用于调试的UART 接口 6 低音和高音控制 14 安静的电源通断功能 22 可用软件增加新功能和提供最多8 个GPIO 7 只用一个单独的12..13MHz时钟运作 15 可扩展外部DAC 的I2S 接口 23 符合RoHS 无铅标准的封装（绿色环保） 8 也可以使用一个24..26MHz时钟运作 16 分离的模拟、数字、IO 供电电源 3. VS1053的结构框图 ​ 结构图的解析我们在使用到某一个部分的时候再回头添加。 4. 电气特性记录​ 作为驱动开发，大部分的电气特性只有在深入调试的时候才会关注，我个人喜欢在遇到的时候再回头看，因为一开始接触新的芯片的时候一下子肯定记不住这么多的特性。但是个人经验还是会在最初开发阶段关心下面几个参数： 4.1 推荐的操作条件 外部输入时钟XTALI的频率：12MHz~13MHz，典型值12.288MHz 内部时钟频率CLKI： 12MHz~55.3MHz，典型值36.864MHz4.1 模拟信号特性 DAC分辨率：典型值是18bit4.2 数字信号特性 SPI输入时钟频率：最大CLKI&#x2F;6，典型值6MHz SCI &amp; SDI写频率：最大CLKI&#x2F;4，典型值9MHz 所有引脚的rise time即电平拉升时间：最大50ns 5. 引脚说明 名称 引脚序号 功能 MICP&#x2F;LINE1 1 麦克风输入、自适应&#x2F;line-in 1的正极 MICN 2 麦克风输入、自适应的负极 DREQ 8 数据请求、输入总线 GPIO2&#x2F;DCLK 9 GPIO2&#x2F;串行数据输入总线的时钟线 GPIO3&#x2F;SDATA 10 GPIO3&#x2F;串行总线的数据线 GPIO6&#x2F;I2S_SCLK 11 GPIO6&#x2F;I2S的时钟线 GPIO7&#x2F;I2S_SDATA 12 GPIO7&#x2F;I2S的数据线 XDCS&#x2F;BSYNC 13 数据片选&#x2F;字节同步 XCS 23 片选输入线，低电平使能 SCLK 28 串行总线时钟线 SI 29 串行总线输入 SO 30 串行总线输出 RX 26 UART接收，没有使用的时候和IOVDD连接在一起的 TX 27 UART发送 RIGHT 39 右声道输出 GBUF 42 耳机的共同缓冲区，不能和地连接 LEFT 46 左声道输出 LINE2 48 右声道的Line-in 2 6. VS1053B的SPI​ VS1053B启动默认选择是SM_SDINEW&#x3D;1。DCLK和SDATA不会被使用，可以当作GPIO使用。BSYNC被当作片选先XCDS使用。 6.1 SPI的读 读指令Instruction[1:0]&#x3D;0b11, Instruction&#x3D;0x03 #define VS1053B_READ_CMD (0x03) 读时序： 片选使能后，主机先向VS1053发送0x03读指令，然后再发送读地址，地址只有4bit；随后VS1053向主机发送一个16bit的数据。也就是说，使能CS后，连续发送2个字节，然后读取两个字节，随后失能CS。 ## 6.2 SPI的写 写指令Instruction &#x3D; 0x02 #define VS1053B_WRITE_CMD (0x02) 写时序 片选是能后，主机想VS1053发送写指令和地址，然后开始发送16bit的数据，发送完数据后，CS失能。 7. 功能描述​ VS1053B支持许多数字信号处理功能，我们在使用某个具体的功能的时候来这里补充。 8. SCI寄存器 #define SET_REG_BITS(reg_val, bits) (reg_val |= (1&lt;&lt;bits)) #define RESET_REG_BITS(reg_val, bits) (reg_val &amp;= (~(1&lt;&lt;bits))) #define VS1053B_MODE_REG (0x00) // Mode control, Reset value 0x4800 #define VS1053B_STATUS_REG (0x01) // Status of VS1053B, Reset value 0x000C #define VS1053B_BASS_REG (0x02) // Built-in base/treble control #define VS1053B_CLOCKF_REG (0x03) // Clock freq+multiplier #define VS1053B_DECODE_T_REG (0x04) // Decode time in seconds #define VS1053B_AUDATA_REG (0x05) // Misc.audio data #define VS1053B_WRAM_REG (0x06) // RAM write or read #define VS1053B_WRAMADDR_REG (0x07) // Base addr for RAM RW #define VS1053B_HDAT0_REG (0x08) // Stream header data0, read only #define VS1053B_HDAT1_REG (0x09) // Stream header data1, read onl #define VS1053B_AIADDR_REG (0x0A) // Start addr of app #define VS1053B_VOL_REG (0x0B) // Volume control #define VS1053B_AICTRL0_REG (0x0C) // Application control reg 0 #define VS1053B_AICTRL1_REG (0x0D) // Application control reg 0 #define VS1053B_AICTRL2_REG (0x0E) // Application control reg 0 #define VS1053B_AICTRL3_REG (0x0F) // Application control reg 0 8.1 SPI_MODE(RW) 默认值0x0800， 复位值0x4800 ​ 根据此表定义SPI的模式： typedef enum { SM_DIff = 0, // Differential, 0-normal in-phase aduio; 1-left channel inverted SM_LAYER12, // Allow MPEG layers Ⅰ & Ⅱ, 0-No; 1-Yes SM_RESET, // Soft reset, 0-noreset; 1-reset SM_CANCLE, // Cancle decoding current file, 0-No; 1-Yes SM_EARSPEAKER_LO, // EarSpeaker low setting , 0-off; 1-acctive SM_TESTS, // Allow SDI Tests, 0-Not allowed; 1-allowed SM_STREAM, // Stream mode, 0-No; 1-Yes SM_EARSPEAKER_HI, // EarSpeaker high setting , 0-off; 1-acctive SM_DACT, // DCLK active edge, 0-rising; 1-falling SM_SDIORD, // SDI bit order, 0-MSB First; 1-LSB First SM_SDISHARE, // Share SPI CS, 0-No; 1-Yes SM_SDINEW, // VS1002 native SPI modes, 0-No; 1-Yes SM_ADPCM, // ADPCM recording active, 0-No; 1-Yes SM_RESERVES, // Reserved SM_LINE1, // mic/line1 selector, 0-MICP; 1-LINE1 SM_CLK_RANGE, // Input clock range, 0-12~13MHz; 1-24~26MHz }VS1053B_MODE; 例如，可以通过使用```SET_REG_BITS(value, SM_SDINEW);```来使能VS1002 New Mode。 8.2 SCI_STATUS(RW) 复位值0x000C typedef enum { SS_DO_NOT_JUMP = 15, // Header in decode, do not fast forward/rewind SS_SWING = 12, // Set swing to +0 dB, +0.5 dB, .., or +3.5 dB SS_VCM_OVERLOAD = 11, // GBUF overload indicator ’1’ = overload SS_VCM_DISABLE = 10, // GBUF overload detection ’1’ = disable SS_VER = 4, // Version SS_APDOWN2 = 3, // Analog driver powerdown SS_APDOWN1 = 2, // Analog internal powerdown SS_AD_CLOCK = 1, // AD clock select, ’0’ = 6 MHz, ’1’ = 3MHz SS_REFERENCE_SEL = 0, // Reference voltage selection, ’0’ = 1.2V, ’1’ = 1.65V }SCI_STATUS; 8.3 SCI_BASS(RW) typedef enum { ST_AMPLITUDE = 12, // Treble Control in 1.5 dB steps (-8..7, 0 = off) ST_FREQLIMIT = 8, // Lower limit frequency in 1000 Hz steps (1..15) SB_AMPLITUDE = 4, // Bass Enhancement in 1 dB steps (0..15, 0 = off) SB_FREQLIMIT = 0, // Lower limit frequency in 10 Hz steps (2..15) }SCI_BASS; 8.4 SCI_CLOCKF(RW) typedef enum { SC_MULT = 13, // Clock multiplier SC_ADD = 11, // Allowed multiplier addition SC_FREQ = 0, // Clock frequency }SCI_CLOCKF; 对于MULT和ADD的设置如下表： 默认值0表示XTAL &#x3D; 12.288MHz 由于最大采样率是XTAL&#x2F;256，所以如果XTAL&lt;12.288MHz，采样率不会有效 例如： SCI_CLOCKF = 0x9BE8 SC_MULT = 4 SC_ADD = 3 SC_FREQ = 0x3E8 = 1000 这就意味着XTAL=1000 x 4000 + 8000000 = 12MHz，始终倍频设置为3.5倍XTAL，即XTAL=3.5 * 12MHz = 42MHz，随后再加上ADD的倍频就变成了XTAL=(3.5 + 2.0) * 12MHz = 66MHz。 8.5 SCI_DECODE_TIME (RW)8.6 SCI_AUDATA (RW)8.7 SCI_WRAM (RW)8.8 SCI_WRAMADDR (W)8.9 SCI_HDAT0 和 SCI_HDAT1 (R)8.10 SCI_AIADDR (RW)8.11 SCI_VOL (RW)8.12 SCI_AICTRL[x] (RW)9. 操作9.1 时钟​ 主时钟频率12.288MHz 9.2 复位 硬件复位：XRESET引脚被拉低，芯片复位，所有的寄存器和状态被还原成初始值。硬件复位后，DREQ会保持22000个时钟周期这么长时间的低电平，也就是说，在主频12.288MHz下，复位后，隔1.8ms后芯片才会起来。 软件复位：通过设置SM_RESET位来启动软复位，然后至少等待2us再去查看DREQ。当DREQ起来后才可以继续进行常规操作。9.3 低功耗模式 通过写SCL_CLOCKF = 0x0000失能PLL来省下功耗； 将SCI_AUDATA写一个比较低的值来省功耗； 关闭所有的audio post-processing； 如果可以的话，还可以写SCI_VOL = 0xFFFF来失能模拟驱动模块；9.4 播放和解码​ 播放和解码是VS1053的基本功能。解码的是SDI的数据。解码数据被内部DAC转化成为一个模拟量。如果没有解码数据，SCI_HDAT0和SCI_HDAT1输出0。​ 当解码器没有数据输入的时候，VS1053B将处于空闲状态，直到串行总线输入了有效数据后，才会启动。9.4.1 播放整个文件​ 这是默认的重放模式。 把音频文件发送给VS1053B； 读取外部的参数值endFillByte; 发送至少2052个字节的endFillByte[7:0]，也就是发送endFillByte的低八位; 把SCI_MODE寄存器的SM_CANCEL位置1； 发送至少32个字节的endFillByte[7:0]; 读取寄存器SCI_MODE。如果SM_CANCEL仍然是置位状态则回到第5步；如果发送了2048个字节后SM_CANCEL还是没有被清零，则执行软件复位； 此时声音已经被成功的发出来了。HDAT0和HDAT1此时应该都是0以此来表明没有解码格式在进行。然后返回1； 9.4.2 取消播放​ 当用户想要从正在播放的音频切换到另一个音频的时候，取消播放就是一个常用的操作了。 将一个音频文件的一小部分发送给VS1053B； 将寄存器SCI_MODE的SM_CANCEL位置位； 持续发送那小部分的音频文件，在这个过程中，每隔32个字节读一次SM_CANCEL位。如果是置位状态，则继续本步骤；如果发送了2048个字节后或者1s后SM_CANCEL还是没有被复位，则执行软复位； 当SM_CANCEL位被复位后，读取外部参数endFillByte的值； 发送2052个字节的endfillByte[7:0]; 此时，HDAT0和HDAT1应该都被清零了，表明此时没有解码在进行，这个时候就可以发送下一个音频文件了。 9.4.3 快速播放​ VS1053支持快速播放。如果你的处理器可以快速提供足够的数据给VS1053B的话，这是一个更优的方式去快进音频。 开始传输一个音频文件给VS1053B； 要设置快速播放，就要设置外部参数playSpeed的值； 继续发送文件； 要退出快速播放模式，就将playSpeed的值写成1; 判断你的处理器是否支持这个功能，就去查看byteRate这个外部参数的值。需要注意的是，byteRate包含的播放文件的数据传输速度，即使是在快速播放模式被是能的情况下，也只是一个名义上的速度。（有点费解……后面看看从实际工程来怎么解释）; 还要注意的是，切换了音频后，播放速度是不会改变的。 9.4.4 没有音频的时候的快进可快退​ 要想快进和快退，你必须要有随机访问音频文件的能力。但是不幸的是，快进和快退不是每时每刻都能执行的，比如在读取音频文件的头部的时候就无法快进快退。 将音频文件的少部分发送给VS1053B； 当要随机访问的时候，读取寄存器SCI_STATUS的SS_DO_NOT_JUMP位。如果这一位被置位了，那么随机访问则不能进行，返回第一步； 如果SS_DO_NOT_JUMP位被复位了，就读取外部参数endFillByte的值； 发送至少2048个字节的endFillByte[7:0]； 在文件中快进或者快退； 继续发送文件； 需要注意的是： 建议快进或者快退的量以每10dB来增加或减少； 寄存器DECODE_TIME不考虑跳转； 咪头不支持随机访问。 9.5 提供PCM数据9.6 Ogg Vorbis 录音​ Ogg Vorbis简称Ogg，是一种音频压缩格式，类似于MP3，但它是完全免费的。​ MP3是有损压缩格式，因此压缩后的数据与标准CD音乐相比是有损失的。Vorbis也是有损压缩，通过使用更加先进的声学模型去减少损失。​ 因此同样位速率（BitRate）编码的OGG与MP3相比听起来会更好一些。 9.7 外部参数​ 外部参数结构体存放在X存储区，地址为0x1E00。可以读取或改变这些外部参数。芯片ID也更容易得到。 #define PARAMETRIC_VERSION 0x0003 struct parametric { /* configs are not cleared between files */ u_int32 chipID; /*1e00/01 Initialized at reset for your convenience */ u_int16 version; /*1e02 - structure version */ u_int16 config1; /*1e03 ---- ---- ppss RRRR PS mode, SBR mode, Reverb */ u_int16 playSpeed; /*1e04 0,1 = normal speed, 2 = twice, 3 = three times etc. */ u_int16 byteRate; /*1e05 average byterate */ u_int16 endFillByte; /*1e06 byte value to send after file sent */ u_int16 reserved[16]; /*1e07..15 file byte offsets */ u_int32 jumpPoints[8]; /*1e16..25 file byte offsets */ u_int16 latestJump; /*1e26 index to lastly updated jumpPoint */ u_int32 positionMsec /*1e27-28 play position, if known (WMA, Ogg Vorbis) */ s_int16 resync; /*1e29 > 0 for automatic m4a, ADIF, WMA resyncs */ 123456789101112131415161718192021222324252627282930union &#123; struct &#123; u_int32 curPacketSize; u_int32 packetSize; &#125; wma; struct &#123; u_int16 sceFoundMask; /*1e2a SCE’s found since last clear */ u_int16 cpeFoundMask; /*1e2b CPE’s found since last clear */ u_int16 lfeFoundMask; /*1e2c LFE’s found since last clear */ u_int16 playSelect; /*1e2d 0 = first any, initialized at aac init */ s_int16 dynCompress; /*1e2e -8192=1.0, initialized at aac init */ s_int16 dynBoost; /*1e2f 8192=1.0, initialized at aac init */ u_int16 sbrAndPsStatus; /*0x1e30 1=SBR, 2=upsample, 4=PS, 8=PS active */ &#125; aac; struct &#123; u_int32 bytesLeft; &#125; midi; struct &#123; s_int16 gain; /* 0x1e2a proposed gain offset in 0.5dB steps, default = -12 */ &#125; vorbis;&#125; i; }; 9.7.1 通用参数 config1：控制MIDI混响、AAC的SBR和PS的设置 playSpeed： byteRate： endFillByte：指明在SM_CANCEL之前已经发送出去的文件的字节值 jumpPoint：包含了一个32bits的偏移量。 9.8 SDI测试（SDI Test）9.9 正弦测试（Sine Test）9.10 引脚测试（PIN Test）9.11 SCI测试（SCI Test）9.12 内存测试（Mmemory Test）9.13 New Sine and Sweep Tests10. VS1053B寄存器10.1 什么情况下需要读这个章节​ 用户希望添加自己的功能的时候，比如添加DSP效果。 我们暂时不需要 11. 说明​ 本篇会随着学习的深入添加内容，逐渐完善。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"STM32","slug":"STM32","permalink":"http://slhking.github.io/tags/STM32/"},{"name":"VS1053","slug":"VS1053","permalink":"http://slhking.github.io/tags/VS1053/"}]},{"title":"土豆烧排骨","date":"2021-04-10T06:23:17.000Z","path":"2021/04/10/土豆烧排骨/","text":"​ 本篇是记录土豆少排骨这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 迷迭香美食 视频地址：简单美味的土豆炖排骨，香到骨子里！材料 序号 名称 数量 1 排骨 1匹 2 土豆 小的2-3个 3 葱姜蒜 少许 4 糖 一勺 5 胡椒粉 一小勺 6 料酒 一勺 7 生抽 一勺 8 老抽 一勺 耗时 焯水：10分钟左右 翻炒如果：5分钟左右 大火烧开：5分钟左右 小火煮：20分钟+15分钟，大约35分钟左右 总计耗时：1小时左右步骤 第一步，排骨焯水，冷水焯水，开水煮开后撇去浮沫，放入葱姜，继续焯水大概3分钟左右，捞出备用； 第二步，焯水过程中，将土豆剥皮，切成块，备用； 第三步，热锅，倒油少许，5分热的时候放入姜片和蒜片，翻炒出香味之后倒入排骨，将排骨炒至金黄色； 第四步，然后把翻炒后的排骨放到砂锅里面，加入料酒、生抽、老抽、糖、胡椒粉、一勺盐，随后加入热水，水量将恰好排骨淹没就足够了； 第五步，大火将砂锅中的水烧开，转小火煮20分钟左右； 第六步，20分钟后，把土豆倒入砂锅里，搅拌下，使其均匀受热；随后小火继续煮15分钟左右； 第七步，出锅，摆盘，将汁水淋到土豆排骨上，最后撒上一点葱花，完美；我的成果​ &#x3D;-&#x3D;没拍照经验​ 这道菜挺简单的，按照视频教的步骤一步一步做就好了~味道挺好的！","tags":[{"name":"土豆烧排骨","slug":"土豆烧排骨","permalink":"http://slhking.github.io/tags/%E5%9C%9F%E8%B1%86%E7%83%A7%E6%8E%92%E9%AA%A8/"},{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"}]},{"title":"学习做梅菜扣肉","date":"2021-04-10T05:25:13.000Z","path":"2021/04/10/学习做梅菜扣肉/","text":"​ 本篇是记录梅菜扣肉这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 黎叔教做菜 视频地址：【咸烧白】四川名菜咸烧白，你们那叫什么？材料 序号 名称 数量 1 瘦一点的五花肉 800克 2 芽菜 根据肉量定 3 豆豉 一勺 4 姜 三四片 5 葱 一根 耗时 煮五花肉：30分钟； 静置、烧开水、炸皮、泡皮、刮皮洗净：20分钟 准备芽菜：5分钟 蒸：60分钟 总共耗时：约2小时步骤 第一步，锅中接入冷水，五花肉肉朝下，皮朝上，放入水中煮，水煮开之后，把浮沫捞走，放入葱姜，继续煮20分钟左右； 第二步，20分钟后，把肉捞出来，放在那种可以漏水的盆里，把皮上煮出来的油刮掉，然后使用老抽趁热上色，最主要的是要上色均匀。上好色之后静置，放冷；在这个过程中可以同时烧一点开水备用； 第三步，锅中倒入油，热油到7、8成的时候，把五花肉的皮向下炸，炸到起皱纹的时候捞出来，一般这个过程挺快的，注意看； 第四步，捞出来后，放到一个大碗里面，用准备好的开水泡，这样是为了让皮的焦味变小，泡的时候皮要向下，泡10分钟左右； 第五步，10分钟后，把皮的皱纹刮掉，刮出金黄色，然后把五花肉清洗干净； 第六步，芽菜用清水清洗2-3次，然后热锅，锅中不需要加入油，把芽菜放到锅里面一直翻炒，直到把芽菜翻炒成一颗一颗可以散开的状态； 第七步，把炒好的芽菜盛到一个碗里面，然后加入切好的泡椒，一勺豆豉，一勺生抽，一勺料酒，7、8颗花椒，搅拌均匀； 第八步，切肉；把五花肉四边修一下，然后顺着五花肉的筋络切，厚度按照筷子的直径比较合适；通常切10片，八片摆在碗的中间，2片分别摆在两边； 第九步，把搅拌好的芽菜添加到摆好的五花肉上，把肉全部覆盖，堆叠成一个尖堆堆，然后压紧一点； 第十步，蒸；蒸锅中加入足够的水，因为要大火蒸一个小时左右；把五花肉放到蒸格上，大火蒸一个小时； 第十一步，成型；一小时后，把五花肉倒扣到另一个碗里面，梅菜扣肉出锅；我的成果 经验​ 这是我第一次做烧白，就成果而言是不合格的。总结了下以下几点没有做好的地方： 五花肉买肥了，导致烧白吃着很闷，容易腻； 切肉的时候切厚了，导致本就肥的烧白吃起来更腻了； 上色上的薄了，这个原因不太好确定，因为我在上色的时候用老抽上了好几次，但是结果还是颜色没黎叔那样好看；有可能是炸皮的时候火候大了或者炸久了，导致后面刮的时候刮掉了太多；","tags":[{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"},{"name":"梅菜扣肉","slug":"梅菜扣肉","permalink":"http://slhking.github.io/tags/%E6%A2%85%E8%8F%9C%E6%89%A3%E8%82%89/"}]},{"title":"学习计划","date":"2021-04-09T03:17:33.000Z","path":"2021/04/09/学习计划/","text":"本贴是对个人学习计划的规划贴。 计划表 学习内容 开始时间 预计周期 Hexo指令 2021-4-2 持续 Linux学习 2021-4-2 持续 Linux SocketCAN学习 2021-4-8 两个月 freeRTOS学习 2021-4-9 一个月 Linux SocketCAN学习进度表 时间 Linux SocketCAN进度 内容 \\ \\ \\ freeRTOS学习进度表 时间 freeRTOS学习 内容 \\ \\ \\","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Hexo指令","date":"2021-04-04T09:36:50.000Z","path":"2021/04/04/Hexo指令/","text":"说明：本文档作为Hexo新手学习笔记文档，遇到新命令即记录，不定时更新ing。 1. 发布文章1. hexo new [layout] &lt;title&gt; 新建一篇文章，如果没有使用layout的话，默认使用_config.yml中的default_layout代替。如果title含空格，使用双引号括起来： hexo new &quot;my test&quot; 参数： 参数 描述 –p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 文章的属性： 设置 描述 默认 layout Layout post或者page title 文章的标题 文章的文件名 data 创建日期 文件建立日期 updated 修改日期 文件更新日期 comments 是否开启评论 trus tags 标签 categories 分类 permalink 覆盖文章网址 文件名 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 新建草稿： hexo new draft &quot;草稿&quot; 发布草稿： hexo publish &quot;草稿&quot; 给文章添加分类和标签： 1234567categories:- 分类- 子分类- 子子分类tags:- 标签1- 标签2","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]