[{"title":"【MM32】第六篇——移植FreeRTOS","date":"2022-05-12T08:06:41.000Z","path":"2022/05/12/【MM32】第六篇——移植FreeRTOS/","text":"1. 前言​ 本篇将会从FreeRTOS官网下载内核源码，移植到MM32F320处理器的工程中，验证方法是创建一个任务，在任务中闪烁LED。 2. 移植2.1 获取源码 FreeRTOS 下载版本： 选择LTS版本。 2.2 移植源文件 将下载下来的源码copy到工程目录的【4_Middleware】文件夹下； 添加根目录下的源文件到工程： 添加port的源文件到工程： 这里需要注意的是，要根据自己的编译环境来选择，比如用的armclang，那么则选择RVDS下的port.c；而如果是gcc，那么则选择GCC下的port.c。我们移植的MM32 MindSDK库，是使用的ARM Compiler 6编译器，用的是GCC下的port.c： 添加内存管理文件 我们建议使用heap_4或者heap_5，我们工程中使用的是heap_4： 设置FreeRTOS的配置文件FreeRTOSConfig.h: 这个文件在内核源码中是不存在的，需要我们自己创建保存，我们将其创建保存在【4_Middleware】的根目录下： 这个头文件的内容是根据官方提供的参考，然后再根据自己使用的处理器以及应用场景来配置的，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#ifndef __FREERTOSCONFIG_H#define __FREERTOSCONFIG_H/* Here is a good place to include header files that are required across your application. */ #include &quot;hal_common.h&quot;#define vPortSVCHandler SVC_Handler #define xPortPendSVHandler PendSV_Handler #define xPortSysTickHandler SysTick_Handler #define configUSE_PREEMPTION 1 #define configUSE_PORT_OPTIMISED_TASK_SELECTION 0 #define configUSE_TICKLESS_IDLE 0 #define configCPU_CLOCK_HZ (72000000) //#define configSYSTICK_CLOCK_HZ (9000000) #define configTICK_RATE_HZ (1000) #define configMAX_PRIORITIES 15 #define configMINIMAL_STACK_SIZE 128 #define configMAX_TASK_NAME_LEN 16 #define configUSE_16_BIT_TICKS 0 #define configIDLE_SHOULD_YIELD 1 #define configUSE_TASK_NOTIFICATIONS 1 #define configTASK_NOTIFICATION_ARRAY_ENTRIES 3 #define configUSE_MUTEXES 1 #define configUSE_RECURSIVE_MUTEXES 0 #define configUSE_COUNTING_SEMAPHORES 0 #define configUSE_ALTERNATIVE_API 0 /* Deprecated! */ #define configQUEUE_REGISTRY_SIZE 10 #define configUSE_QUEUE_SETS 0 #define configUSE_TIME_SLICING 0 #define configUSE_NEWLIB_REENTRANT 0 #define configENABLE_BACKWARD_COMPATIBILITY 0 #define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5 #define configSTACK_DEPTH_TYPE uint16_t #define configMESSAGE_BUFFER_LENGTH_TYPE size_t /* Memory allocation related definitions. */ #define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE (1024*10) #define configAPPLICATION_ALLOCATED_HEAP 0 #define configSTACK_ALLOCATION_FROM_SEPARATE_HEAP 1 /* Hook function related definitions. */ #define configUSE_IDLE_HOOK 0 #define configUSE_TICK_HOOK 0 #define configCHECK_FOR_STACK_OVERFLOW 0 #define configUSE_MALLOC_FAILED_HOOK 0 #define configUSE_DAEMON_TASK_STARTUP_HOOK 0 /* Run time and task stats gathering related definitions. */ #define configGENERATE_RUN_TIME_STATS 0 #define configUSE_TRACE_FACILITY 0 #define configUSE_STATS_FORMATTING_FUNCTIONS 0 /* Co-routine related definitions. */ #define configUSE_CO_ROUTINES 0 #define configMAX_CO_ROUTINE_PRIORITIES 1 /* Software timer related definitions. */ #define configUSE_TIMERS 1 #define configTIMER_TASK_PRIORITY 5 #define configTIMER_QUEUE_LENGTH 10 #define configTIMER_TASK_STACK_DEPTH configMINIMAL_STACK_SIZE /* Interrupt nesting behaviour configuration. */ #define configKERNEL_INTERRUPT_PRIORITY 255#define configMAX_SYSCALL_INTERRUPT_PRIORITY 191#define configMAX_API_CALL_INTERRUPT_PRIORITY 191/* Define to trap errors during development. */ //#define configASSERT( ( x ) ) if( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ ) /* FreeRTOS MPU specific definitions. */ #define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0 #define configTOTAL_MPU_REGIONS 8 /* Default value. */ #define configTEX_S_C_B_FLASH 0x07UL /* Default value. */ #define configTEX_S_C_B_SRAM 0x07UL /* Default value. */ #define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY 1 #define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS 1 /* ARMv8-M secure side port related definitions. */ #define secureconfigMAX_SECURE_CONTEXTS 5 /* Optional functions - most linkers will remove unused functions anyway. */ #define INCLUDE_vTaskPrioritySet 1 #define INCLUDE_uxTaskPriorityGet 1 #define INCLUDE_vTaskDelete 1 #define INCLUDE_vTaskSuspend 1 #define INCLUDE_xResumeFromISR 1 #define INCLUDE_vTaskDelayUntil 1 #define INCLUDE_vTaskDelay 1 #define INCLUDE_xTaskGetSchedulerState 1 #define INCLUDE_xTaskGetCurrentTaskHandle 1 #define INCLUDE_uxTaskGetStackHighWaterMark 0 #define INCLUDE_xTaskGetIdleTaskHandle 0 #define INCLUDE_eTaskGetState 0 #define INCLUDE_xEventGroupSetBitFromISR 1 #define INCLUDE_xTimerPendFunctionCall 0 #define INCLUDE_xTaskAbortDelay 0 #define INCLUDE_xTaskGetHandle 0 #define INCLUDE_xTaskResumeFromISR 1 #endif /* __FREERTOSCONFIG_H */ 2.3 设置编译路径要想编译器找到FreeRTOS内核的相关头文件，就需要将这些头文件的所在路径在mdk工程中添加进去： 设置好编译路径后先编译一下，确保编译FreeRTOS的源文件没有问题。 3. 验证3.1 编写驱动文件​ 我们需要配置MM32F3270的时钟，然后还需要控制LED来验证移植，所以还需要写一个LED的驱动；我们还添加了一个调试串口的驱动，都放到了源代码中。 3.2 创建任务​ 由于在FreeRTOSConfig.h中我们没有选择静态分配内存： 12345#define configSUPPORT_STATIC_ALLOCATION 0 #define configSUPPORT_DYNAMIC_ALLOCATION 1 #define configTOTAL_HEAP_SIZE (1024*10) #define configAPPLICATION_ALLOCATED_HEAP 0 #define configSTACK_ALLOCATION_FROM_SEPARATE_HEAP 1 所以只能调用动态分配的那个任务创建函数：xTaskCreate： 123456BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, // 任务的入口函数 const char * const pcName, // 任务的名称 const configSTACK_DEPTH_TYPE usStackDepth, // 分配给任务的栈大小 void * const pvParameters, // 传递给任务的参数 UBaseType_t uxPriority, // 分配给任务的优先级 TaskHandle_t * const pxCreatedTask ) // 返回的任务句柄值 这个函数的返回值： 12pdPASS = 创建成功errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY = 创建失败 根据任务参数的描述，我们需要一个任务的入口函数，形式如：void TestCode(void *parameter)，然后创建一个任务： 123456xTaskCreate(TestCode, \\ // 任务的入口函数 &quot;Test&quot;, \\ // 任务的名称 128, \\ // 分配给任务的栈大小:word NULL, \\ // 传递给任务的参数 1, \\ // 分配给任务的优先级 NULL); // 返回的任务句柄值 3.3 任务函数​ 我们对于任务的示例函数的实现如下： 12345678910111213void TestCode(void *parameter)&#123; volatile uint32_t cnt = 0; printf(&quot;\\r\\nTest Task\\r\\n&quot;); while(1) &#123; Driver_LED_Write(RedLED, LED_ON); vTaskDelay(500); Driver_LED_Write(RedLED, LED_OFF); vTaskDelay(500); printf(&quot;LED task running :%d\\r&quot;, cnt++); &#125;&#125; 在里面闪烁LED，并打印运行次数信息，大约每隔1s打印一次。 3.4 开启任务调度 接口：void vTaskStartScheduler( void ) 当调用这个函数后，正常情况下这个函数之后的代码都不会运行到，比如： 1234567891011121314151617181920int main(void)&#123; volatile uint32_t cnt = 0; SystemClockConfig(); Driver_SysTick_Config(); Driver_LED_Init(); DBG_UART_Init(); xTaskCreate(TestCode, &quot;Test&quot;, 128, NULL, 1, NULL); vTaskStartScheduler(); printf(&quot;Hello China.\\r\\n&quot;); while(1) &#123; &#125; return 0;&#125; 这个代码中【Hello China.】就不会被打印出来。 3.5 现象 ​ 开发板运行这个例程已经有一天多的时间了，从这个计数值也可以看出来，说明移植FreeRTOS到MM32基本没有问题了。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第五篇——串口与printf重定向","date":"2022-05-12T08:06:22.000Z","path":"2022/05/12/【MM32】第五篇——串口与printf重定向/","text":"1. 概述​ 本篇主要介绍使用MM32的MindSDK开发串口的驱动程序以及重定向printf函数所需要关心的注意事项，由于是使用库开发，比较简单，过程中会着重讲一些注意点，代码的编写仅以代码展示来表现。 2. 初始化UART2.1 配置GPIO​ 评估板上使用的是UART1，用到的引脚是PB6和PB7，将这两个引脚配置位复用输出以及浮空输入： 12345678910111213141516171819202122232425262728293031/* PB6 -- UART1 TX PB7 -- UART1 RX*/#define UART1_TX_PIN GPIO_PIN_6#define UART1_RX_PIN GPIO_PIN_7#define UART1_PORT GPIOB#define UART1_GPIO_CLK_EN() RCC_EnableAHB1Periphs(RCC_AHB1_PERIPH_GPIOB, true)/** * @brief 初始化串口的GPIO * */static void Drv_UART_GPIO_Init(void)&#123; GPIO_Init_Type gpio_init; UART1_GPIO_CLK_EN(); /* PA9 - UART1_TX. */ /* PA10 - UART1_RX. */ gpio_init.Pins = UART1_TX_PIN; gpio_init.PinMode = GPIO_PinMode_AF_PushPull; // 复用推挽输出 gpio_init.Speed = GPIO_Speed_50MHz; GPIO_Init(UART1_PORT, &amp;gpio_init); GPIO_PinAFConf(UART1_PORT, gpio_init.Pins, GPIO_AF_7); gpio_init.Pins = UART1_RX_PIN; gpio_init.PinMode = GPIO_PinMode_In_Floating; // 浮空输入 gpio_init.Speed = GPIO_Speed_50MHz; GPIO_Init(UART1_PORT, &amp;gpio_init); GPIO_PinAFConf(UART1_PORT, gpio_init.Pins, GPIO_AF_7);&#125; 2.2 配置UART参数​ 调试串口使用的是UART1，波特率选择115200，数据位8位，1位停止位，没有校验位： 1234567891011121314151617181920#define UART_INSTANCE UART1#define UART_INSTANCE_CLK_EN() RCC_EnableAPB2Periphs(RCC_APB2_PERIPH_UART1, true)void Drv_UART_Init(void)&#123; UART_Init_Type uart_init; UART_INSTANCE_CLK_EN(); // 使能UART1的时钟 Drv_UART_GPIO_Init(); // 初始化UART1的GPIO uart_init.ClockFreqHz = Drv_GetSysClockFreq()&gt;&gt;1; // 时钟 uart_init.BaudRate = 115200; // 波特率 uart_init.WordLength = UART_WordLength_8b; // 数据位 uart_init.StopBits = UART_StopBits_1; // 停止位 uart_init.Parity = UART_Parity_None; // 校验位 uart_init.XferMode = UART_XferMode_RxTx; // 传输方向：收发 uart_init.HwFlowControl = UART_HwFlowControl_None; // 硬件流控制 UART_Init(UART_INSTANCE, &amp;uart_init); // 将参数配置到寄存器进行初始化 UART_Enable(UART_INSTANCE, true); // 使能UART1&#125; MM32的库还需要配置UART的时钟，一般选择为UART所在总线APB1&#x2F;2的时钟，我的系统里APB总线时钟是系统时钟2分频后输出的： 123456/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR &amp;= ~(0xF&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCO 3. 重定向printf3.1 重定向__FILE结构体​ 在ARM的C&#x2F;C++用户手册中提到，要想重定向printf需要重定向__FILE结构体，但是在MDK下，V6版编译器已经内置重定向了，而V5是没有的，所以我们需要根据所选择的编译器版本来决定是否重定向__FILE结构体： 12345#if defined (__ARMCC_VERSION) &amp;&amp; (__ARMCC_VERSION &lt; 6010050)struct __FILE&#123; int handle;&#125;;#endif 3.2 重定向fputc​ 在MDK下重定向fputc： 123456789FILE __stdout;int fputc(int ch, FILE *f) &#123; /* Your implementation of fputc(). */ while ( 0u == (UART_STATUS_TX_EMPTY &amp; UART_GetStatus(UART_INSTANCE)) ) &#123;&#125; UART_PutData(UART_INSTANCE, (uint8_t)(ch)); return ch;&#125; fputc的函数参数、返回值是固定形式的，只需要在函数体内调用UART的发送函数，将参数ch发送出去即可。 4. 使用​ 我们在main函数内初始化UART后，调用printf打印输出： 123456789101112131415161718192021222324252627282930313233343536#include &quot;drv_led.h&quot;#include &quot;drv_sysclk.h&quot;#include &quot;drv_systick.h&quot;#include &quot;drv_uart.h&quot;#include &quot;hal_common.h&quot;#include &lt;stdio.h&gt;/** * @brief ARM处理器程序入口函数 * * @return int 通常main函数不会有返回值 */int main(void)&#123; /* 定义LED的状态变量，按键按下时取反 */ LED_Status status = off; /* 初始化系统时钟频率为120MHz */ SystemClockConfig(); /* 配置滴答定时器的技术周期是1kHz */ Drv_SysTick_Config(); /* 初始化用户LED的GPIO和默认状态 */ Drv_LED_Init(); /* 初始化串口 */ Drv_UART_Init(); while(1) &#123; /* TDO Your Task */ status = !status; Drv_LED_Write(user_led, status); // 控制LED printf(&quot;LED状态:%s\\r\\n&quot;, (status==on) ? &quot;on&quot; : &quot;off&quot;); HAL_Delay(500); &#125;&#125; 5. 测试结果：","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第四篇——滴答定时器","date":"2022-05-10T15:21:13.000Z","path":"2022/05/10/【MM32】第四篇——滴答定时器/","text":"1. 前言​ 滴答定时器是cortex内核中的内置定时器，是一个24bit的向下计数定时器。本篇将会介绍滴答定时器的相关寄存器及其配置，实现一个ms级别的延时，通过LED的闪烁来验证，所以需要将LED的驱动移植到本次的工程中。 2. Cortex-M3的滴答定时器​ 本章节主要介绍cortex-m3内核的滴答定时器的相关寄存器，参考手册《Cortex-M3 Devices Generic User Guide》。 2.1 控制和状态寄存器SYST_CSR Bits 名词 描述 [31:17] \\ 保留位 [16] COUNTFLAG 如果滴答定时器的计数值计数到0，那么读取这一位的话就会返回1 [15:3] \\ 保留位 [2] CLKSOURCE 滴答定时器的时钟源：0&#x3D;外部时钟；1&#x3D;处理器时钟 [1] TICKINT 使能滴答定时器的异常请求：0&#x3D;计数到0时不产生SysTick异常请求；1&#x3D;计数到0会产生异常请求； [0] ENABLE 使能计数器：0&#x3D;关闭计数器；1&#x3D;开启计数器 这个寄存器可以设置滴答定时器的时钟源、中断使能及其本身的使能或者关闭，还可以从这个寄存器读取到其是否计数到0。我们需要首先选择这个定时器的时钟源，然后再来使能中断和开启计数器。 滴答定时器的时钟源 ​ 从寄存器的描述可以看到，滴答定时器有两种时钟源：处理器的时钟或者外部时钟。处理器的时钟没啥好说的，我们将处理器的时钟设置为多少，滴答定时器的时钟就是多少，而外部时钟是什么呢？ ​ 滴答定时器的外部时钟是芯片设计厂商，我们来看一下灵动微的MM32F3270给滴答定时器设计的外部时钟是怎样的。在MM32F3270的用户手册时钟树那里前面可以看到： 在MM32F3270处理器中，内核的滴答定时器时钟的外部时钟源还可以是AHB总线时钟8分频后的时钟。 ​ 通常我们会将这个寄存器的值初始化的时候设置为0x7，时钟是处理器的时钟，且使能中断，开启计数器。 2.2 预装载值寄存器SYST_RVR Bits 名称 作用 [31:24] \\ 保留位 [23:0] RELOAD 预装载值，滴答定时器从这个值开始向下计数，计数到0后在下一个周期重新从这个值开始计数 ​ 滴答定时器是一个24bit的向下计数器，所以其预装载寄存器可以设置的位数也只有低24bits，最大可以设置的值是0xFFFFFF&#x3D;16777215。 ​ 假设我们期望滴答定时器每隔1ms进入一次中断，也就是让滴答定时器在其时钟频率下开始向下计数RELOAD这么多次需要耗费的时间是1ms，设滴答定时器的时钟&#x3D;xMHz，那么reload的值就应该是xMHz&#x2F;1kHz &#x3D;xK。比如MM32F3270处理器的AHB总线时钟是120MHz，那么只需要将reload的值设置为120k就可以让滴答定时器每隔1ms进入一次中断，而120k是小于16777215的，是合法的值。 2.3 当前计数值寄存器SYST_CVR Bits 名称 描述 [31:24] Reserved 保留位 [23:0] CURRENT 当前计数值 ​ 这个寄存器很简单，就是表明滴答定时器当前的计数值是多少，可读可写。 2.4 校准值寄存器SYST_CALIB Bits 名称 作用 [31] NOREF 表明设备是否给处理器提供了支持的时钟信号，0&#x3D;提供了；1&#x3D;未提供；如果没有提供支持的时钟，那么滴答定时器的时钟源默认选择系统时钟且对CLKSOURCE那一位的写操作将会被忽略； [30] SKEW 表明TENMS值是否是正确的：0&#x3D;正确；1&#x3D;异常 [29:24] - 保留位 [23:0] TENMS 复位重载值是100ms，用作系统时钟的偏差。如果这个值读出来是0，那么表明校准值就是一个未知值 3. 如何配置滴答定时器3.1 直接调用core_m3.h内联函数​ 在core_m3.h文件中有一个配置滴答定时器的内联函数： 123456789101112131415__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)&#123; if ((ticks - 1UL) &gt; SysTick_LOAD_RELOAD_Msk) &#123; return (1UL); /* Reload value impossible */ &#125; SysTick-&gt;LOAD = (uint32_t)(ticks - 1UL); /* set reload register */ NVIC_SetPriority (SysTick_IRQn, (1UL &lt;&lt; __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */ SysTick-&gt;VAL = 0UL; /* Load the SysTick Counter Value */ SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable SysTick IRQ and SysTick Timer */ return (0UL); /* Function successful */&#125; 它的参数就是设置的预装载值，选择的时钟源默认就是系统时钟，并且也使能了中断，所以我们可以在自己的应用程序中据此做一次封装： 123456789101112131415int Driver_SysTick_Config(void)&#123; uint32_t prioritygroup = 0x00U; uint32_t SystemCoreClock = Driver_GetSysClockFreq(); /* Configure the SysTick to have interrupt in 1ms time basis*/ if(SysTick_Config(SystemCoreClock/1000) &gt; 0) &#123; return -1; &#125; /* Configure the SysTick IRQ priority */ prioritygroup = NVIC_GetPriorityGrouping(); NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(prioritygroup, 15, 0)); return 0;&#125; 我们默认将其预装载值设置为系统时钟除以1000，即每隔1ms进入一次滴答定时器的中断。 3.2 根据寄存器地址映射直接操控寄存器​ 根据前面介绍的滴答定时器的寄存器，按照自己所需设置寄存器的值即可。滴答定时器在内存中映射的基地址是： 各寄存器的地址： 那么我们的程序就可以这样操作： 12345678910111213141516171819202122232425#define SYSTICK_BASE_ADDR (0xE000E010)typedef struct&#123; unsigned int CSR; unsigned int RVR; unsigned int CVR; unsigned int CALIB;&#125;SYSTICK_REG;#define SYSTICK ((SYSTICK_REG*)SYSTICK_BASE_ADDR)int Driver_SysTick_ConfigUseREG(void)&#123; SYSTICK-&gt;RVR = Driver_GetSysClockFreq()/1000 - 1; SYSTICK-&gt;CVR = 0; SYSTICK-&gt;CSR |= (1&lt;&lt;0) | // Enable counter (1&lt;&lt;1) | // Enable Interupt (1&lt;&lt;2); // Clock:cpu clock /* Configure the SysTick IRQ priority */ uint32_t prioritygroup = 0x00U; prioritygroup = NVIC_GetPriorityGrouping(); NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(prioritygroup, 15, 0)); return 0;&#125; 3.3 滴答定时器的中断服务函数12345static volatile uint32_t uwTick = 0;__WEAK void SysTick_Handler(void)&#123; uwTick++;&#125; 4. 验证​ 要验证也很简单，我们利用刚才中断服务函数中的那个全局递增变量，仿照ST的HAL库写一个延时函数： 1234567891011121314151617181920unsigned int HAL_GetTick(void)&#123; return uwTick;&#125;void HAL_Delay(unsigned int Delay)&#123; volatile uint32_t tickstart = HAL_GetTick(); volatile uint32_t wait = Delay; /* Add a freq to guarantee minimum wait */ if (wait &lt; 0xFFFFFFFFU) &#123; wait += (uint32_t)(1); &#125; while ((HAL_GetTick() - tickstart) &lt; wait) &#123; &#125;&#125; 然后操控一个GPIO延时改变电平，即闪烁一个LED： 1234Driver_LED_Write(RedLED, LED_ON);HAL_Delay(500);Driver_LED_Write(RedLED, LED_OFF);HAL_Delay(500); 根据灯的闪烁现象来粗布判断延时是否准确，更精准的测试可以用逻辑分析仪或者示波器来测试引脚的电平翻转时间。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第三篇——时钟系统","date":"2022-05-10T05:56:21.000Z","path":"2022/05/10/【MM32】第三篇——时钟系统/","text":"1. 前言​ 本文将介绍MM32F3270系处理器的时钟系统，将分别以内部高速时钟HSI、外部高速时钟作为输入时钟源，经锁相环PLL分频和倍频后得到更高的系统时钟，本次代码将会从寄存器层次来配置，而不是使用MindSDK库。 2. 时钟树​ 我们先来认识下MM32F3270的时钟树： 我们将时钟树从【SYSCLK】即【系统时钟】处将这张图一分为二，左侧是时钟输入源以及时钟信号输出到MCO线；右侧是将系统时钟经过分频输出给USB和各总线、外设以及定时器。 ​ 我们可以看到，MM32F3270有四个时钟输入源： HSI——内部高速时钟； HSE——外部高速时钟； LSE——外部低速时钟； LSI——内部低速时钟； 这四个输入时钟皆可用于配置系统时钟SYSCLK，其中HSI和HSE还可以用作PLL的输入源，经过分频和倍频得到更高主频的系统时钟。当配置好系统时钟后，就可以分频配置USB、总线和外设的时钟了。 2.1 HSI配置系统时钟 如果SYSCLK选择以HSI作为系统时钟，那么，SYSCLK的值就是HSI经1&#x2F;2&#x2F;4&#x2F;8&#x2F;16&#x2F;32&#x2F;64&#x2F;128倍分频后的值，最大只能达到HSI的时钟频率8MHz； 如果SYSCLK选择以PLL作为系统时钟，且PLL的输入时钟源来自于HSI，可以看到，是HSI经过1分频后输入到锁相环PLL单元的。也就是说，此时PLL的输入时钟就是HSI的8MHz，然后经PLL的倍频器PLLMUL及其分频器PLLDIV设置倍频系数和分频系数输出给SYSCLK；假设PLLMUL&#x3D;30，PLLDIV&#x3D;2，那么SYSCLK&#x3D;PLLSRC&#x2F;PLLDIV*PLLMUL&#x3D;8MHz&#x2F;2*30&#x3D;120MHz; 2.2 HSE配置系统时钟 和HSI需经过一个分频器再输出给SYSCLK不同的是，当使用HSE直接作为SYSCLK的时钟源时，中间不需要分频，即HSE的时钟频率就是系统频率； 如果SYSCLK的时钟源是PLL且PLL的时钟源是HSE，那么HSE会经过一个固定分频系数的分频器2分频后输入给PLL，然后再经由PLL分频和倍频得到更高的系统时钟，假设HSE&#x3D;8MHz，那么这个时候，PLLDIV就可以设置为1，而PLLMUL照样还是30，同样可以得到120MHz的系统时钟； 2.3 LSI配置系统时钟​ 可以看到，系统时钟还可以选择LSI作为时钟输入源，得到一个更低频的系统时钟。 2.4 时钟输出2.4.1 USB时钟​ 从时钟树的分析可以看到，USB的时钟来自于PLL的输出时钟分频之后的时钟，它支持的最高时钟频率是48MHz，所以如果我们的PLL输出时钟被配置为系统时钟支持的最大时钟频率120MHz，那么USB的时钟最大只能是由PLL经过3分频之后的时钟40MHz；而想要USB工作在最大时钟频率，我们只能将PLL的输出时钟配置为96MHz，再经由2分频后输出给USB，这时候系统时钟的频率也只能达到96MHz。 2.4.2 总线时钟​ MM32F3270的总线有以下几条： AHB总线：时钟是系统时钟SYSCLK经过AHB预分频器分频后产生的； APB1：时钟是AHB总线时钟经APB1预分频器分频后产生的； APB2：时钟是AHB总线时钟经APB2预分频器分频后产生的； 2.4.3 外设和定时器时钟​ 外设分为： AHB总线上的外设：时钟就是AHB总线的时钟； APB1总线上的外设：时钟就是APB1总线的时钟； ABP2总线上的外设：时钟就是APB2总线的时钟； ADC：时钟是APB2总线时钟经ADC预分频器分频后产生的； 高级定时器1和8：时钟是系统时钟SYSCLK经高级定时器预分频器分频后产生的； ​ 定时器分为： 滴答定时器：滴答定时器的时钟可以来自于AHB总线时钟8分频后产生，也可以来自其它时钟源，将分为单独的一章节来介绍内核的滴答定时器； APB1总线上的定时器：如果APB1的预分频系数是1，那么APB1总线上的定时器的时钟就是APB1不分频后产生的时钟；而如果APB1的预分频系数不为1，那么此时APB1总线上的定时器时钟就是将APB1总线的时钟2倍频之后的时钟； APB2总线上的定时器：时钟分析和APB1总线上的定时器时钟类似； 2.4.4 MCO​ MCO：微控制器时钟输出，可以将选择的时钟源输出到MCO引脚上，其来源可以是： PLL输出时钟2分频； HSI; HSE; LSE; SYSCLK; LSI； 2.4.5 RTC时钟​ RTC的时钟来源有2： HSE经128分频后的时钟； LSE； LSI； 2.4.6 独立看门狗IWDG的时钟​ IWDG的时钟只能来源于LSI。 3. 配置系统时钟​ 配置系统时钟除了配置RCC单元之外，还要配合内部FLASH特性和电源管理单元来设置。配合内部FLASH是因为读写内部flash的时候，如果主频过高，就要设置内部flash的预缓冲区和等待周期，目的是为了正常的从flash中读取指令和读写数据；配置电源管理单元则是MM32F3270这个处理器的要求，需要我们去遵从。 3.1 配置内部Flash的参数 使能内部Flash时钟 ​ 内部Flash是挂载再AHB总线上的，因而需要在AHB总线上使能Flash这个外设的时钟，通过查看RCC的AHB寄存器，可以看到是在RCC的AHB1ENR寄存器中使能内部Flash的时钟的： 我们需要将RCC_AHB1ENR的第13位写1： 1RCC-&gt;AHB1ENR |= (1u &lt;&lt; 13u); // 使能FLASH外设 配置等待周期 ​ 在MM32F3270的用户手册中的第【2.3.1】小节有这样一段话： 这段话是中文就不多做解释了，来看一下官方给的系统时钟和Flash latency值之间的关系表： 所以从这个表中我们可以得到，如果要系统时钟工作在96MHz或者120MHz，Flash的latency值需要设置成4，而设置Flash的latency值是在Flash的ACR寄存器： 1FLASH-&gt;ACR |= (4&lt;&lt;0); // 设置Flash的等待周期 3.2 配置电源管理单元​ 此经验是阅读MM32F3270的手册，看到3.5.1章节PWR的CR1寄存器发现的： 所以在配置时钟前，还需要： 12PWR-&gt;CR1 &amp;= ~(2&lt;&lt;14);PWR-&gt;CR1 |= (2&lt;&lt;14); // 如果系统时钟需要达到最大频率 120MHz，需要将 VOS 设置为 2’b10 即 1.7V 3.3 配置HSI用作系统时钟​ 配置HSI用作系统时钟主要由两个步骤： 使能HSI； 配置时钟控制寄存器（RCC_CR）中的HSION 位为1，使能HSI； 等待时钟控制寄存器（RCC_CR）中的 HSIRDY 位被置位为 1，表示 HSI 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源。 系统时钟源选择HSI； 通过配置时钟配置寄存器（RCC_CFGR）的SW 位来选择系统时钟； 通过读取时钟配置寄存器（RCC_CFGR）的SWS 位，判断当前系统时钟的时钟源。 上电复位后的系统时钟就是HSI 3.4 配置HSE用作系统时钟​ 配置HSE用作系统时钟主要由两个步骤： 使能HSE； 配置时钟控制寄存器（RCC_CR）中的HSEON 位为 1，使能 HSE 等待时钟控制寄存器（RCC_CR）中的HSERDY 位被置位为1，表示 HSE 稳定，会输出有效时钟信号，此时才可被选择使用作为系统时钟或外设时钟源。 系统时钟源选择HSI； 通过配置时钟配置寄存器（RCC_CFGR）的SW 位来选择系统时钟； 通过读取时钟配置寄存器（RCC_CFGR）的SWS 位，判断当前系统时钟的时钟源。 所以根据前面的内容，得到配置代码： 1234567891011121314151617181920static void SystemConfigUseHSE(void)&#123; /* 使能总线外设时钟 */ RCC-&gt;AHB1ENR |= (1u &lt;&lt; 13u); // 使能FLASH外设 FLASH-&gt;ACR |= (4&lt;&lt;0); // 设置Flash的等待周期 /* 使能PWR/DBG */ RCC-&gt;APB1ENR |= (1&lt;&lt;28); PWR-&gt;CR1 &amp;= ~(2&lt;&lt;14); PWR-&gt;CR1 |= (2&lt;&lt;14); // 如果系统时钟需要达到最大频率 120MHz，需要将 VOS 设置为 2’b10 即 1.7V /* 使能HSE */ RCC-&gt;CR |= (1&lt;&lt;16); while(0 == (RCC-&gt;CR&amp;(1&lt;&lt;17)));// 等待HSI稳定 /* 选择HSI作为系统时钟源 */ // 00：选择 HSE 输出用作系统时钟; 01：选择 HSE 输出用作系统时钟; 10：选择 PLL 输出用作系统时钟; 11：选择 LSI 输出用作系统时钟 RCC-&gt;CFGR |= 1; while(0 == (RCC-&gt;CFGR&amp;(1&lt;&lt;1))); // 等待HSE用作系统时钟变&#125; 3.5 配置PLL用作系统时钟3.5.1 HSI用作PLL的输入时钟将HSI用作PLL输入时钟配置高频的系统时钟，步骤如下： 配置时钟控制寄存器（RCC_CR）中的HSION 位为1，使能HSI； 等待时钟控制寄存器（RCC_CR）中的 HSIRDY 位被置位为 1，表示 HSI 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源； 配置PLL 配置寄存器 （RCC_PLLCFGR）中PLLMUL（倍频系数）和PLLDIV（分频系数）控制位； 配置时钟控制寄存器（RCC_CR）中的PLLON 位为1，使能PLL； 等待时钟控制寄存器（RCC_CR）中的 PLLRDY 位被置位为 1，表示 PLL 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源。 配置RCC_CFGR选择PLL作系统时钟源并等待稳定； 所以根据前面的内容，得到配置代码： 1234567891011121314151617181920/* 配置HSO和PLL */RCC-&gt;CR |= (1&lt;&lt;0); // 使能HSIwhile(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;1))); // 等待HSI稳定RCC-&gt;PLLCFGR |= (0&lt;&lt;0); // 配置PLL的时钟源RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16);RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8);RCC-&gt;PLLCFGR |= (0&lt;&lt;8); // 配置PLL的分频系数:1RCC-&gt;CR |= (1&lt;&lt;24); // 使能PLLwhile(0 == (RCC-&gt;CR &amp; (1&lt;&lt;25)));// 等待PLL时钟稳定/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCORCC-&gt;CFGR |= (2&lt;&lt;0); // 选择PLL输出用作系统时钟while(0 == (RCC-&gt;CFGR &amp; (2&lt;&lt;2))); // 等待PLL输出用作系统时钟稳定 3.5.2 HSE用作PLL的输入时钟将HSE用作PLL输入时钟配置高频的系统时钟，步骤如下： 配置时钟控制寄存器（RCC_CR）中的HSEON 位为 1，使能HSE； 等待时钟控制寄存器（RCC_CR）中的HSERDY 位被置位为1，表示 HSE 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源； 配置 PLL 配置寄存器（RCC_PLLCFGR）中的 PLLSRC 位为 1，选择 HSE 时钟用作 PLL 输入时钟源； 配置PLL 配置寄存器（RCC_PLLCFGR）中的PLLXTPRE 位，选择HSE 或者HSE 2 分频时钟为PLL 输入时钟源； 配置PLL 配置寄存器 （RCC_PLLCFGR）中PLLMUL（倍频系数）和PLLDIV（分频系数）控 制位； 配置时钟控制寄存器（RCC_CR）中的PLLON 位为1，使能PLL； 等待时钟控制寄存器（RCC_CR）中的 PLLRDY 位被置位为 1，表示 PLL 稳定，可输出有效时钟，此时才可被选择使用作为系统时钟或外设时钟源。 配置RCC_CFGR选择PLL作系统时钟源并等待稳定； 所以根据前面的内容，得到配置代码： 123456789101112131415161718192021/* 配置HSE和PLL */RCC-&gt;CR |= (1&lt;&lt;16); // 使能HSEwhile(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;17)));// 等待HSE稳定RCC-&gt;PLLCFGR |= (1&lt;&lt;0); // 配置PLL的时钟源RCC-&gt;PLLCFGR |= (1&lt;&lt;1); // 配置PLL的时钟源2分频后再作为时钟输入源RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16);RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8);RCC-&gt;PLLCFGR |= (0&lt;&lt;8); // 配置PLL的分频系数:1RCC-&gt;CR |= (1&lt;&lt;24); // 使能PLLwhile(0 == (RCC-&gt;CR &amp; (1&lt;&lt;25)));// 等待PLL时钟稳定/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCORCC-&gt;CFGR |= (2&lt;&lt;0); // 选择PLL输出用作系统时钟while(0 == (RCC-&gt;CFGR &amp; (2&lt;&lt;2))); // 等待PLL输出用作系统时钟稳定 3.6 配置总线时钟123456/* 配置系统时钟、AHB、APB时钟 */RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHzRCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCO ​ 根据RCC_CFGR寄存器以及时钟树的分析来自定义配置。 3.7 综合代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#define __USE_HSE (0)#define __USE_HSE_PLL (1)#define __USE_HSI_PLL (0)void SystemClockConfig(void)&#123; /* 使能总线外设时钟 */ RCC-&gt;AHB1ENR |= (1u &lt;&lt; 13u); // 使能FLASH外设 FLASH-&gt;ACR |= (4&lt;&lt;0); // 设置Flash的等待周期 /* 使能PWR/DBG */ RCC-&gt;APB1ENR |= (1&lt;&lt;28); PWR-&gt;CR1 &amp;= ~(2&lt;&lt;14); PWR-&gt;CR1 |= (2&lt;&lt;14); // 如果系统时钟需要达到最大频率 120MHz，需要将 VOS 设置为 2’b10 即 1.7V RCC-&gt;CR &amp;= ~((1&lt;&lt;16) | (1&lt;&lt;24) ); // 关闭HSE/PLL #if __USE_HSE SystemConfigUseHSE();#elif __USE_HSI_PLL RCC-&gt;CR &amp;= ~(1&lt;&lt;0); // 先关闭HSI /* 配置HSE和PLL */ RCC-&gt;CR |= (1&lt;&lt;0); // 使能HSI while(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;1))); // 等待HSI稳定 RCC-&gt;PLLCFGR &amp;= ~(1&lt;&lt;0); // 配置PLL的时钟源HSI RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16); RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍 RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8); RCC-&gt;PLLCFGR |= (1&lt;&lt;8); // 配置PLL的分频系数:2#elif __USE_HSE_PLL /* 配置HSE和PLL */ RCC-&gt;CR |= (1&lt;&lt;16); // 使能HSE while(0 == ((RCC-&gt;CR)&amp;(1&lt;&lt;17)));// 等待HSE稳定 RCC-&gt;PLLCFGR |= (1&lt;&lt;0); // 配置PLL的时钟源HSE RCC-&gt;PLLCFGR &amp;= ~(1&lt;&lt;1); // 配置PLL的时钟源HSE不分频后再作为时钟输入源 RCC-&gt;PLLCFGR &amp;= ~(0x7F&lt;&lt;16); RCC-&gt;PLLCFGR |= (29&lt;&lt;16); // 配置PLL的倍频系数:30倍 RCC-&gt;PLLCFGR &amp;= ~(0x7&lt;&lt;8); RCC-&gt;PLLCFGR |= (1&lt;&lt;8); // 配置PLL的分频系数:2#endif RCC-&gt;CR |= (1&lt;&lt;24); // 使能PLL while(0 == (RCC-&gt;CR &amp; (1&lt;&lt;25)));// 等待PLL时钟稳定 /* 配置系统时钟、AHB、APB时钟 */ RCC-&gt;CFGR |= (0&lt;&lt;4); // AHB不分频 RCC-&gt;CFGR |= (4&lt;&lt;8); // APB1 2分频 RCC-&gt;CFGR |= (4&lt;&lt;11); // APB2 2分频 RCC-&gt;CFGR |= (2&lt;&lt;22); // PLL输出时钟3分频后输出给USB：120MHz/3=40MHz RCC-&gt;CFGR |= (7&lt;&lt;24); // PLL输出时钟2分频后输出到MCO RCC-&gt;CFGR |= (2&lt;&lt;0); // 选择PLL输出用作系统时钟 while(0 == (RCC-&gt;CFGR &amp; (2&lt;&lt;2))); // 等待PLL输出用作系统时钟稳定&#125; 4. 获取系统时钟和总线时钟​ 获取系统时钟是根据寄存器的内容，简单的加减乘除后写成程序计算的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#define LSI_VALUE (40000)#define HSI_VALUE (8000000)#define HSE_VALUE (8000000)uint32_t Driver_GetSysClockFreq(void)&#123; uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U; uint32_t sysclockfreq = 0U; tmpreg = RCC-&gt;CFGR; /* 获取系统时钟源 */ switch(tmpreg &amp; RCC_CFGR_SWS_MASK) &#123; case RCC_SYSCLKSOURCE_STATUS_HSI: &#123; sysclockfreq = HSI_VALUE; break; &#125; case RCC_SYSCLKSOURCE_STATUS_HSE: &#123; sysclockfreq = HSE_VALUE; break; &#125; case RCC_SYSCLKSOURCE_STATUS_LSI: &#123; sysclockfreq = LSI_VALUE; break; &#125; case RCC_SYSCLKSOURCE_STATUS_PLLCLK: &#123; /* 获取PLL的输入时钟源 */ if(RCC-&gt;PLLCFGR&amp;0x01) // HSE用作PLL的输入时钟 &#123; if(RCC-&gt;PLLCFGR&amp;0x02) // HSE二分频后输入给PLL &#123; pllclk = HSE_VALUE&gt;&gt;1; &#125; else // HSE部分变频直接输出给PLL &#123; pllclk = HSE_VALUE; &#125; &#125; else // HSI用作PLL的输入时钟 &#123; pllclk = HSI_VALUE; &#125; prediv = (RCC-&gt;PLLCFGR&gt;&gt;8)&amp;0x07; // PLL的分频系数：PLLCFGR[10:8] pllmul = (RCC-&gt;PLLCFGR&gt;&gt;16)&amp;0x7F; // PLL的倍频系数: PLLCFGR[22:16] sysclockfreq = pllclk * (pllmul+1) / (prediv+1); break; &#125; default:break; &#125; return sysclockfreq;&#125; 5. 验证123456789101112131415#include &quot;driver_sysclk.h&quot;uint32_t sysfreq = 0;int main(void)&#123; SystemClockConfig(); sysfreq = Driver_GetSysClockFreq(); while(1) &#123; &#125; return 0;&#125; 通过调试查看寄存器的值以及变量sysfreq的值是否如预期。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第二篇——点亮LED","date":"2022-05-07T06:31:03.000Z","path":"2022/05/07/【MM32】第二篇——点亮LED/","text":"1. 前言​ 本次实验是在第一篇的基础上进行功能扩展，要实现的是点亮板子上的LED。 2. 工程模板移植 将【Template】工程文件夹copy为另一个工程文件夹【LightLED】 更改工程名字：Template –&gt; LightLED ​ 然后双击打开工程。 根据工程名重新管理工程 配置工程编译输出文件的名称 ​ 如果要编译生成hex文件，则讲途中圈起来的【Create HEX File】这一项勾选上。 设置调试器 ​ 因为工程模板是将配置文件和编译输出文件全部删除掉的，所以需要重新设置下调试器选项，步骤就不再重复说明了。 验证编译 ​ 为确保移植过来的默认设置没有问题，上面的设置好了之后最好先编译一次。 3. 编写LED的驱动3.1 新建LED的驱动源文件和头文件​ 新建文件、保存文件以及添加至工程不再赘述。 3.2 编写LED驱动的头文件​ 我习惯在头文件中对外设硬件驱动的引脚、时钟、硬件名称等，用宏定义的方式在头文件中定义，所以这里我将LED的GPIO相关信息定义到头文件中，而LED的GPIO是哪些我们可以通过板子的原理图获知： 序号 LED 引脚 1 RED PA15 2 GREEN PB3 3 BLUE PB4 4 YELLOW PB5 根据原理图可知，GPIO输出低电平的时候，发光二极管导通发亮，输出高电平的时候熄灭，所以我们在头文件中进行了如下宏定义： 12345678910111213141516171819202122232425262728293031/* driver_led.h */#ifndef __DRIVER_LED_H#define __DRIVER_LED_H#define RED_PIN GPIO_PIN_15#define RED_PORT GPIOA#define RED(STATUS) GPIO_WriteBit(RED_PORT, RED_PIN, STATUS)#define GREEN_PIN GPIO_PIN_3#define GREEN_PORT GPIOB#define GREEN(STATUS) GPIO_WriteBit(GREEN_PORT, GREEN_PIN, STATUS)#define BLUE_PIN GPIO_PIN_4#define BLUE_PORT GPIOB#define BLUE(STATUS) GPIO_WriteBit(BLUE_PORT, BLUE_PIN, STATUS)#define YELLOW_PIN GPIO_PIN_5#define YELLOW_PORT GPIOB#define YELLOW(STATUS) GPIO_WriteBit(YELLOW_PORT, YELLOW_PIN, STATUS)#define LED_GPIO_CLK_EN() &#123;RCC_EnableAHB1Periphs(RCC_AHB1_PERIPH_GPIOA, true);\\ RCC_ResetAHB1Periphs(RCC_AHB1_PERIPH_GPIOA);\\ RCC_EnableAHB1Periphs(RCC_AHB1_PERIPH_GPIOB, true);\\ RCC_ResetAHB1Periphs(RCC_AHB1_PERIPH_GPIOB);&#125;typedef enum&#123; LED_ON = 0, LED_OFF&#125;LED_Status;#endif /* __DRIVER_LED_H */ 3.3 编写LED驱动的源文件 LED的驱动源文件需要知道LED的引脚，所以需要包含我们自己新建的【driver_led.h】； 需要使能LED的GPIO的时钟，所以需要包含HAL库文件【hal_rcc.h】； 需要初始化LED的GPIO，调用的是【hal_gpio.c】里面的函数，所以需要包含【hal_gpio.h】; 123#include &quot;driver_led.h&quot;#include &quot;hal_rcc.h&quot;#include &quot;hal_gpio.h&quot; 编写LED的驱动一般步骤是： 使能GPIO的时钟； 初始化GPIO为输出模式（推挽输出）； 封装LED的输出控制接口； 初始化LED的GPIO 1234567891011121314151617181920212223242526272829303132void Driver_LED_Init(void)&#123; /* 调用GPIO的HAL库对象结构体声明GPIO对象 */ GPIO_Init_Type gpio_init; /* 使能GPIO的时钟 */ LED_GPIO_CLK_EN(); /* 设置GPIO的模式 */ gpio_init.PinMode = GPIO_PinMode_Out_PushPull; gpio_init.Speed = GPIO_Speed_50MHz; /* 选择引脚初始化 */ gpio_init.Pins = RED_PIN; // 红灯 GPIO_Init(RED_PORT, &amp;gpio_init); gpio_init.Pins = GREEN_PIN; // 绿灯 GPIO_Init(GREEN_PORT, &amp;gpio_init); GPIO_PinAFConf(GREEN_PORT, gpio_init.Pins, GPIO_AF_15); gpio_init.Pins = BLUE_PIN; // 蓝灯 GPIO_Init(BLUE_PORT, &amp;gpio_init); gpio_init.Pins = YELLOW_PIN; // 黄灯 GPIO_Init(YELLOW_PORT, &amp;gpio_init); /* 设置LED的默认状态：熄灭 */ RED(LED_OFF); GREEN(LED_OFF); BLUE(LED_OFF); YELLOW(LED_OFF);&#125; 其中对于绿灯的引脚PB3，需要将其复用做普通GPIO。 封装LED的写控制接口 为了便于后续向平台层封装，我们将LED的写控制接口函数名称统一为Driver_LED_Write，考虑到要控制的LED可能不止一个，因而使用了枚举类型将所有的LED类型整合在了一起放到了头文件： 123456typedef enum&#123; RedLED = 0, GreenLED, BlueLED, YellowLED&#125;LED_Type; 那么封装的接口函数实现如下： 123456789101112131415161718192021222324252627void Driver_LED_Write(LED_Type type, LED_Status status)&#123; switch(type) &#123; case RedLED: &#123; RED(status); break; &#125; case GreenLED: &#123; GREEN(status); break; &#125; case BlueLED: &#123; BLUE(status); break; &#125; case YellowLED: &#123; YELLOW(status); break; &#125; default:break; &#125;&#125; 然后将初始化函数接口和写控制接口在头文件中声明，方便别的源文件调用： 12void Driver_LED_Init(void);void Driver_LED_Write(LED_Type type, LED_Status status); 4. 验证4.1 main函数调用LED接口 要调用LED的驱动接口，就需要包含其驱动头文件【driver_led.h】； 在main函数中首先调用初始化LED的函数； 然后再调用LED的写控制接口控制LED； 123456789101112131415#include &quot;driver_led.h&quot;int main(void)&#123; Driver_LED_Init(); Driver_LED_Write(RedLED, LED_ON); Driver_LED_Write(GreenLED, LED_ON); Driver_LED_Write(BlueLED, LED_ON); Driver_LED_Write(YellowLED, LED_ON); while(1) &#123; &#125; return 0;&#125; 4.2 编译烧录​ 代码编写完毕之后，就可以编译看下是否有严重的警告或者错误，如果编译通过了，则可以使用调试器在线调试或者直接烧录到板子上查看现象。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"【MM32】第一篇——新建MDK工程","date":"2022-05-07T05:53:14.000Z","path":"2022/05/07/【MM32】第一篇——新建MDK工程/","text":"1. 前言​ 本文的目的是从0开始搭建一个基于MM32单片机的MDK工程，使用的主控芯片是MM32F3277G9P，移植使用的SDK是灵动微官方的MindSDK。 2. SDK的获取2.1 SDK在官网的位置​ 在写本文的时候(2022.5.7)，灵动微官方将其最新的MindSDK放在其官网的【支持】栏中： 要获取这个SDK的资源需要注册登录。 2.2 选择SDK 选择开发工具 官方支持的开发工具有：armgcc、MDK和IAR，按需选择： 本文选择的是MDK。 选择主控 目前(2022.5.7)官方支持的有3种主控对应其三张评估板： 本文选择的是F3270系列的评估板。 构建工程 根据自己的需求选择好开发工具和主控之后，就点击【BUILD PROJECT】构建工程： 构建好之后，就会跳转到生成的SDK样板记录，点击标题即可下载到本地： 3. SDK的结构​ 从官网下载下来的SDK文件目录如图所示： components(组件)：提供了一些三方组件的源文件，如LVGL，内存管理、TinyUSB等； demo_apps：提供了一些三方组件的例程； device：当前处理器的一些库文件和核心文件： 其中【mdk】中的linker下的文件，是MDK工程中需要我们指定的分散加载链接文件，在稍后新建工程的时候会介绍到。 driver_examples：当前处理器基于此SDK的一些驱动例程； 对于中这个SDK，我们要移植到自己工程中的只有【device】下的文件，其它文件夹都是给我们做参考用。 4. 新建工程4.1 构建工程结构​ 在新建MDK工程之前，理应先设计好自己的工程的目录结构，以便于管理文件，这个地方完全根据个人习惯或者公司规定，没有定式，我个人习惯构建如下的工程目录结构： 这些文件夹的作用如图所示： 我们将MM32的SDK中的【device】下的所有文件和文件夹copy到【7_CoreDevice】中： 4.2 创建MM32F3277G9P的MDK工程 新建工程 选择工程的保存路径：【ProjectName】–&gt;【8_Project】； 给工程取名字，例如【Template】，然后保存： 选择主控芯片型号：MM32F3277G9P 选择好之后点击【确定】，然后回弹出来一个管理软件组件的窗口，我们一开始先不管这个，直接点击【OK】。 4.3 管理MDK工程结构​ 刚才初创了MDK工程后，原始的MDK工程结构通常是无法满足我们自己的工程管理需求的，因而需要进行重新设计管理。 改变MDK工程名 点击菜单栏的【工程管理按钮】： 在【Project Targets】中我们可以增加、删除、修改工程名： 我们将目标工程名字和我们之前初创的时候取的工程名一样： 管理目标工程的文件组 在【Groups】窗口中就是当前目标工程会包含的文件组，我们将其设计为和我们在【4.1】小节构建的工程结构一致，只是对于工程结构中的【8_Project】这一项去掉： 当一个文件组中有很多的层次时，比如我们的【7_CoreDevice】中有核心文件，也有HAL库文件，我们可以根据层次进行这样的设计： 添加文件 ​ 当我们将文件组设计好之后，就可以根据这个设计添加文件到对应的组别了，比如我们可以将HAL库文件添加到【7_CoreDevice&#x2F;HAL】这个文件组中： 对于HAL库文件，我们不一定都要全部添加进来，通常都是按需添加。 我们需要添加的MCU核心文件如图所示： 一个是系统配置文件【systetem_mm32f3277g.c】，另一个是系统启动文件【startup_mm32f3277g7.s】。 至此，管理目标工程的基本步骤就到此结束了，如果后续的开发需要添加额外的目标工程、文件组或者文件，根据这几步按需做就好了。 4.4 配置工程​ 当我们管理好基本的工程之后，还要设置这个工程，比如编译器版本选择、编译条件选择、编译路径选择、分散加载等等，我们来分别说明下。 ​ 首先点击菜单栏的【Options for Target】进入工程配置界面： 编译器版本选择 ​ MDK的编译器版本支持V5和V6两种，目前常用的是V5版本，也有V6版本的，V6版本对比于V5，是在编译优化上的提升，通常V6编译速度会比V5快，且MindSDK的分散加载文件的指令用到了V6编译器的指令，所以我们默认还是选择V6版本的编译器： 编译条件 ​ 编译条件主要涉及两个东西，一个是全局宏定义标志，另一个是代码全局设置，比如是否支持C99，优化等级选择多高等等： 红框中选中的是最低等级的优化等级，然后后面的C99使用MindSDK所必须要选择设置上的，因为MindSDK的库文件代码使用了这种标准。 编译路径 ​ 编译器在编译过程中的预处理阶段会去展开源文件中#include的头文件，如果不指定使用到的这些头文件所在的路径，那么编译器就找不到无法展开，编译就会出错，所以我们需要设置这里的编译路径： 凡是源文件中会用到的头文件（自定义的或者库文件的头文件）所在路径都必须在这里设置添加进来，C标准库的不用（比如stdio.h这些）： 选择好之后点击【OK】就完成了编译路径的设置，如果后续有新增文件夹路径，再来这里添加进去就好。 指定分散加载文件 ​ MindSDK有个特别的地方就是，它提供的启动代码在初始化堆栈指针的时候，是通过分散加载文件完成的，而不是直接在启动文件中完成的，就是我们在前文提到的【mdk】中的linker下的那个文件，因而我们需要去指定那个文件到MDK工程的链接中： ① 在【Options for Target】中选择【Linker】项； ② 此项去勾选； ③ 选择MindSDK提供的分散加载文件； 设置好后的结果如下图所示： 设置调试器 根据自己的调试器类型选择，比如ST-Link&#x2F;J-Link等，我使用的是官方评估板，上面自带有他们的MM32-Link： 选择好调试器之后，点击旁边的【Settings】进入调试器设置： ① 点击【Settings】进入设置； ② 此处可以观察调试器是否将PC和处理器正常连接了； ③ 此处勾选上后，在MDK中下载程序到处理器之后，处理器就可以自动复位运行程序； 当上述的工程配置都完成之后，就点击【OK】退出配置。 5. 编译工程5.1 新建源文件&#x2F;头文件​ 经过前面的步骤，我们对当前工程完成了基本设置，但是还缺少一个东西：main函数。至于为何mdk工程必须要有一个确切实现的main函数，大家可以翻阅ARM的C标准库的手册，里面有详细说明。 ​ 我们将main函数放到源文件【main.c】中定义实现，但是当前工程是没有【main.c】的，因而我们需要新建一个： 点击这个快捷键后，在MDK的编辑区就会弹出一个新的文件编辑窗口： 这时候我们点击保存或者按快捷键【ctrl+s】保存： 我们将main.c保存到【1_App】中，理所应当的，文件名处我们就填写【main.c】就好： 然后点击【保存】即可。 ​ 新建文件之后，如果是源文件，且还期望其能被编译，就要将这个文件添加到MDK工程中，添加文件的步骤前面已经讲过了，除了那种方式，我们也可以在目标文件组双击鼠标左键去寻找添加，大家自己尝试： 5.2 编辑文件​ 编辑没啥好说的，根据C语言规则以及我们的设计需求设计程序就好，我们这里做模板工程用，因而就在【main.c】中定义实现main函数就好： 123456#include &lt;stdio.h&gt;int main(void)&#123; return 0;&#125; 5.3 编译​ 按快捷键【F7】或者在菜单栏点击编译选项编译:","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"MM32","slug":"MM32","permalink":"http://slhking.github.io/tags/MM32/"}]},{"title":"ROS的文件系统","date":"2022-04-29T22:22:43.000Z","path":"2022/04/30/ROS的文件系统/","text":"1. 概述​ ROS文件系统指的是在硬盘上ROS源代码的组织形式，其结构大致如下图所示： WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&amp;静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"链表的学习","date":"2022-04-22T23:32:25.000Z","path":"2022/04/23/链表的学习/","text":"1. 什么是链表？​ 链表，别名链式存储结构或者单链表，用于存储逻辑关系为“一对一”的数据。链表不限制数据的物理存储状态，使用链表存储的数据元素，其物理存储位置是随机的。 2. 链表的节点​ 链表中每个数据的存储都由以下两部分组成： 数据元素本身，其所在的区域成为数据域； 指向直接后继元素的指针，所在的区域称为指针域； 1234567typedef struct List *pList;struct List&#123; int data; // 数据域 struct List *next; // 指针域&#125;; ​ 一个完整的链表需要以下及部分组成： 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的为止； 节点：链表中的节点又细分为头节点、首元节点： 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题； 首元节点：由于头节点的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据的节点的一个称谓，没有实际意义； 其它节点； 注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。 3. 链表的主要操作3.1 创建一个无头节点的链表​ 创建一个链表需要做如下工作： 声明一个头指针，如果有必要，可以声明一个头节点； 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系； 1 3.2 求链表长度123456789101112int GetListLength(pList npList)&#123; int i = 0; pList p = npList; while(p) &#123; p = p-&gt;next; i++; &#125; return i;&#125; 3.3 查找链表节点​ 按序号查找: 1234567891011121314pList FindListByNum(int k, pList npList)&#123; pList p = npList; int i = 1; while(p!=NULL &amp;&amp; i&lt;k) &#123; p = p-&gt;next; i++; &#125; if(i==k) return p; return NULL;&#125; ​ 按值查找: 12345678910pList FineListByValue(int value, pList npList)&#123; pList p = npList; while(p!=null &amp;&amp; p-&gt;data!=value) &#123; p = p-&gt;next; &#125; return p;&#125; 3.4 在链表中插入节点","tags":[{"name":"C语言","slug":"C语言","permalink":"http://slhking.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单片机","slug":"单片机","permalink":"http://slhking.github.io/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"嵌入式Linux学习疑惑随手记","date":"2022-04-22T14:52:34.000Z","path":"2022/04/22/嵌入式Linux学习疑惑随手记/","text":"1. 嵌入式Linux中App开发人员是如何得知可以操控哪些底层硬件的？ 系统会自动挂载，如果没有自动挂载就需要去手动执行挂载命令；我们怎么直到是否自动挂载呢？在终端执行： 1cat /proc/mounts 查看系统设备： 1ls /dev/* -l # 查看所有的设备，包括其主设备号和次设备号 在Linux内核里面，有两类驱动程序：字符(char)设备驱动程序和块(block)设备驱动程序。 图中，c代表字符设备驱动程序， 89就是设备的主设备号，0&#x2F;1&#x2F;2就是设备的次设备号。设备节点对应哪一个设备驱动程序通过主设备号来确定，而次设备号则是决定该设备节点对应的是设备驱动程序中对应的哪一个硬件。 2. Linux中对文件的操作 打开文件：open 需要包含的头文件： 123#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt; 可以调用的API： 12int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode); 当成功打开一个文件后，open的返回值会是这个文件的描述符句柄，如果打开失败，那么它的返回值就是-1。 参数flags的范围： flags 涵义 O_RDONLY 只读 O_WRONLY 只写 O_RDWR 可读可写 O_APPEND 以附件的方式打开文件，在对该文件进行写的时候，会偏移到文件的末尾开始写 O_ASYNC Enable signal-driven I&#x2F;O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input or output becomes possible on this file descriptor. This feature is available only for terminals, pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs. O_CLOEXEC Enable the close-on-exec flag for the new file descriptor O_CREAT If pathname does not exist, create it as a regular file.这个Flags会用到mode O_DIRECT Try to minimize cache effects of the I&#x2F;O to and from this file. O_DIRECTORY If pathname is not a directory, cause the open to fail O_DSYNC Write operations on the file will complete according to the requirements of synchronized I&#x2F;O data integrity completion. O_EXCL Ensure that this call creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then open() fails with the error EEXIST. O_LARGEFILE Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be opened. O_NOATIME Do not update the file last access time (st_atime in the inode) when the file is read(2). O_NOCTTY If pathname refers to a terminal device—see tty(4)—it will not become the process’s controlling terminal even if the process does not have one. O_NOFOLLOW If pathname is a symbolic link, then the open fails, with the error ELOOP. O_NONBLOCK&#x2F;O_NDELAY When possible, the file is opened in nonblocking mode. O_PATH Obtain a file descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to perform operations that act purely at the file descriptor level. O_SYNC Write operations on the file will complete according to the requirements of synchronized I&#x2F;O file integrity completion(by contrast with the synchronized I&#x2F;O data integrity completion provided by O_DSYNC.) O_TMPFILE Create an unnamed temporary regular file. O_TRUNC If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will be truncated to length 0. If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored. Otherwise, the effect of O_TRUNC is unspecified. 当flags支持O_CREAT时，可以选择的mode有： mode 作用 S_IRWXU user (file owner) has read, write, and execute permission S_IRUSR user has read permission S_IWUSR user has write permission S_IXUSR user has execute permission S_IRWXG group has read, write, and execute permission S_IRGRP group has read permission S_IWGRP group has write permission S_IXGRP group has execute permission S_IRWXO others have read, write, and execute permission S_IROTH others have read permission S_IWOTH others have write permission S_IXOTH others have execute permission S_ISUID set-user-ID bit S_ISGID set-group-ID bit S_ISVTX sticky bit 其中，user&#x2F;group&#x2F;others指代的什么？ 示例：打开一个“只读”文件测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;/** * @brief * ./open hello.txt * @param argc * @param argv * @return int */int main(int argc, char const *argv[])&#123; char buf[1024] = &#123;0&#125;; int len = 0; printf(&quot;Open a file by read only.\\r\\n&quot;); int fd = open(argv[1], O_RDONLY); if(fd == -1) printf(&quot;Open file failed.\\r\\n&quot;); printf(&quot;Read file: \\r\\n&quot;); while( (len = read(fd, buf, 1024)) &gt; 0 ) &#123; printf(&quot;%s&quot;, buf); &#125; printf(&quot;\\r\\n&quot;); printf(&quot;Try to write: ABCD\\r\\n&quot;); len = write(fd, &quot;ABCD&quot;, 4); if(len == -1) printf(&quot;Write to file failed.\\r\\n&quot;); close(fd); return 0;&#125; 输出结果： 1234567book@100ask:~/workspace/FileOption$ ./open_ro hello.txt Open a file by read only.Read file: Hello World!Try to write: ABCDWrite to file failed.","tags":[{"name":"Linux","slug":"Linux","permalink":"http://slhking.github.io/tags/Linux/"},{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"ROS的快速体验","date":"2022-04-22T09:36:56.000Z","path":"2022/04/22/ROS的快速体验/","text":"​ 本文参考的是赵虚左老师的博客和视频。主要目的是记录一下快速使用ROS输出Hello World!这个信息的步骤。 1. 概述​ ROS设计的编程语言主要是C++和python，使用哪一门语言进行开发取决于我们熟悉使用哪一门语言。 ​ 实现输出Hello World!的步骤分为如下几步： 创建一个工作空间； 在工作空间中创建一个功能包； 编辑源文件； 编辑配置文件； 编译并执行； 2. 创建和编译2.1 创建工作空间并初始化123mkdir -p 自定义空间名称/srccd 自定义空间名称catkin_make 需要注意的是，使用mkdir创建工作空间的时候，后面必须要有/src；初始化的时候，必须是在创建好的工作空间内进行初始化。 2.2 进入src创建ros功能包并添加依赖12cd srccatkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 123roscpp: C++的依赖包rospy: python的依赖包std_msgs: 标准输入输出的依赖包 2.3 使用C++实现输出Hello World2.3.1 ROS功能包内容 进入刚才创建的ros功能包： 1cd ros功能包 可以看到这里面也有一个src文件夹，我们需要将当前ros功能包要实现的功能的源代码文件放在这个文件夹下，头文件放在ros功能包中的include文件夹下。需要注意区分工作空间下的src文件夹和ros功能包中的src文件夹。 2.3.2 创建和编辑节点源文件 进入ros功能包中的src文件夹新建源文件 12cd srcgedit hello.cpp 使用gedit新建并打开hello.cpp，如果不是在vmware或者vxwork中而是使用ssh连接虚拟机的话，需要将gedit换做vim。 编辑hello.cpp 12345678910111213#include &quot;ros/ros.h&quot;int main(int argc, char *argv[])&#123; //执行 ros 节点初始化 ros::init(argc,argv,&quot;hello&quot;); //创建 ros 节点句柄(非必须) ros::NodeHandle n; //控制台输出 hello world ROS_INFO(&quot;hello world!&quot;); return 0;&#125; 我们要使用ros的库API，需要包含它的头文件。在main函数中，一个简单的ros节点创建和信息输出总结为如下几步： 使用ros-&gt;init接口初始化节点，第三个参数是节点名称； 使用ros-&gt;NodeHandle 创建当前ros节点的句柄； 调用ros标准信息输出接口ROS输出信息； 编辑好源代码之后保存退出编辑； 2.3.3 编译配置文件 编辑ros功能包中的配置文件CMakelist.txt 12cd ~/工作空间/src/ros功能包gedit CMakelist.txt 找到默认被注释掉的add_executable和target_link_libraries，默认分别是在136行和149行： 将他们按照下面的格式修改： 123456add_executable(步骤3的源文件名 src/步骤3的源文件名.cpp)target_link_libraries(步骤3的源文件名 $&#123;catkin_LIBRARIES&#125;) 然后保存退出编辑。 2.3.4 编译功能包 进入工作空间根目录编译 12cd ~/Desktop/工作空间catkin_make 如果提示编译失败： 则根据提示去修改，比如我们这里最初提示在配置文件CMakelist.txt中没有找到hello_node.cpp，也就是我们的配置文件没有修改正确，那我们又去ros功能包中修改CMakelist.txt文件： 再重新回到工作空间编译，编译成功会有如下提示： 3. 执行​ 需要打开两个终端： 在终端1中启动ROS： 1roscore 在终端2中启动编译出来的ros节点 123cd ~/工作空间source ./devel/setup.bashrosrun 包名 C++节点 当我们执行后看到了打印信息则证明我们的ROS环境搭建基本没有问题。 source ~/工作空间/devel/setup.bash可以添加进.bashrc文件，使用上更方便，这一步是配置环境变量。","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"ROS环境搭建","date":"2022-04-22T08:42:02.000Z","path":"2022/04/22/ROS环境搭建/","text":"​ 本文参考的是赵虚左老师的博客以及视频。 1. 安装虚拟机​ 需要下载的软件：VxWork或者vmware以及ubuntu虚拟机镜像，ubuntu镜像学习使用的版本是20.04。虚拟机的安装步骤比较简单，网上有很多参考，这里略过不写。 2. 安装ROS2.1 配置ubuntu的软件和更新 需要保证途中的复选框都勾选上，且下载自那个地方要选择一个国内的服务器。 2.2 设置安装源 默认的安装源： 1sudo sh -c &#x27;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 国内清华的安装源： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 国内中科大的安装源： 1sudo sh -c &#x27;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.ustc.edu.cn/ros/ubuntu/ `lsb_release -cs` main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#x27; 2.3 设置ROS的key1sudo apt-key adv --keyserver &#x27;hkp://keyserver.ubuntu.com:80&#x27; --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 2.4 更新源sudo apt update 2.5 安装ROSsudo apt install ros-noetic-desktop-full 这个安装过程受限于网络环境和网络速度，过程可能比较漫长，而且过程中还可能会报错，如果报错了就重新执行这条命令，它会从错误的地方开始继续安装，不会从头安装。需要耐心等待。 2.6 配置环境变量12echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 3. ROS依赖安装 首先安装构建依赖的相关工具： sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 初始化rosdep 12sudo rosdep initrosdep update 如果一切顺利的话： 但是一般都会在rosdep update这一步出错，在这一步，如果能翻墙的话可以翻墙后重复执行一直到成功，如果不能翻墙，则参考赵虚左老师的方法：http://www.autolabor.com.cn/book/ROSTutorials 4. 验证环境 开启三个终端（ctrl+shift+t可以打开一个终端）； 终端1输入指令：roscore；开启ROS核心控制器 终端2输入指令：rosrun turtlesim turtlesim_node；开启乌龟控制图形界面 终端3输入指令：rosrun turtlesim turtle_teleop_key；开启获取键盘鼠标的ros程序 将鼠标光标放置终端3窗口，然后按下键盘的上下左右键，如果能控制乌龟则说明ROS环境搭建完成；","tags":[{"name":"ROS","slug":"ROS","permalink":"http://slhking.github.io/tags/ROS/"}]},{"title":"VS1053B开发——使用STM32CubeIDE新建工程","date":"2021-04-11T15:46:42.000Z","path":"2021/04/11/VS1053B开发——使用STM32CubeIDE新建工程/","text":"​ 本篇是记录的是使用STM32CubeIDE新建一个开发VS1053B芯片的工程，包括了对基本外设的配置和FATFS系统以及freeRTOS系统的添加。 我的VS1053B开发系列所有文章 VS1053B开发——手册学习笔记 VS1053B开发——使用STM32CubeIDE新建工程。 源码地址 新建工程源码：VS1053B_Prj_NewProject 使用命令 git clone https://gitee.com/slhking/vs1053-b_-prj_-new-project.git将工程下载到本地。 1. 开发环境 硬件环境：STM32F103 + VS1053B + 咪头 + 运放喇叭 软件环境：STM32CubeIDE 串口调试工具：Mobaxterm 其他工具：需要SD卡，因为使用了FATFS来读取SD卡内的MP3文件 预先使用这些，后面使用到了再来添加 2. 硬件框图3. 程序流程图4. 建立工程 使用HAL库； MCU主频72MHz； 使用freeFTOS; 使用FATFS； 4.1 使用STM32CubeIDE创建基础工程 第一步，创建工程文件夹：在保存项目工程的路径下新建项目文件夹，我的就取名叫VS1053B_Prj，如图： 第二步，打开STM32CubeIDE，选择工作区路径，我们就选择在项目文件夹下，然后点击Launch，如图: 第三步，新建STM32工程，如图： 第四步，选择芯片，首先搜索我们使用的芯片，然后根据封装选择具体是哪一个，随后点击Next，如图： 第五步，设置工程名称及模板，首先给工程取一个名字，我们就和项目名称一样，然后操作条件即工程模板就使用默认参数，随后点击Finish，在弹出来的框体中选择Yes，如图： 第六步，初始化系统时钟，我习惯上先初始化系统时钟，选择外部晶振，随后去配置PLL时钟源来自HSE，系统时钟源来自PLLCLK，主频设置为72MHz，然后敲击回车让STM32CubeMX自动得到时钟方案，如图： 第七步，设置Debug，默认是不使能Debug功能，但是我们开发过程中肯定会使用到Debug功能的，因而这里随意选择一种都可以，如图： 第八步，配置SDIO，选择SD 4 bits Wide Bus，然后其他参数默认就好，如图： 第九步，配置FATFS。我们需要FATFS文件系统来读取SD卡内的MP3文件，所以需要添加FATFS。模式选择SD Card，参数使用默认参数，如图： 第十步，配置MCU和VS1053B之间通信使用的SPI，我们首先查看原理图，使用的是哪几个引脚以及使用的是哪一个SPI，原理图如图： ​ 可以看到，使用的是MCU的SPI2，引脚是: 引脚号 SPI 线 功能描述 PB12 SPI2_CS0 硬件片选 PB13 SPI2_SCK SPI时钟线 PB14 SPI2_MISO SPI主机接收从机输出 PB15 SPI2_MOSI SPI主机输出从机输入 所以我们来配置SPI2的参数，首先选择全双工主机模式，然后是硬件片选，随后是分频倍数，因为在上一篇我们知道，在配置VS1053的时候VS1053B的SPI频率在外部晶振是12.288MHz时最大是6MHz，读写RAM的时候最大是9MHz，所以我们在初始化的时候选择8分频。即36MHz&#x2F;8&#x3D;4.5MHz，其他的先暂时使用默认值，如图： - 第十一步，配置USART1，原理图上使用的引脚是PA9和PA10，如图： 所以我们在STM32CubeMX里来配置USART1，首先选择USART1，模式选择异步通信，波特率设置为115200，数据位是8bit，没有校验位，1bit的停止位，全双工模式，如图： - 第十二步，配置freeFTOS，接口那里选择V1或者V2都可以，我选择的是V2（对freeRTOS的了解还不深，解释不了为什么，到后面学习freeRTOS后再来天坑），其他参数使用默认值，如图： - 第十三步，设置工程参数，主要是设置一个给配置的外设添加对应的.c和.h文件，如图所示： - 第十四步，保存STM32CubeMX的配置，键盘按Ctrl + S，然后生成代码，然后在过程中弹出来的窗口都选择Yes就好了，如图： 4.2 观察生成的工程​ STM32CubeIDE下使用STM32CubeMX生成的代码，其结构和IDE各窗口如图所示： 因为使用了STM32CubeMX，而且在可见的未来，我们后续还会使用CubeMX来配置某些外设，因而在编辑代码的时候就要遵循一个规则，即在USER CODE BEGIN和USER CODE END之间添加我们想要添加的代码，这样是为了避免下次使用CubeMX配置别的外设的时候，重新生成代码时，我们在这个区域外添加的代码被覆盖消失掉，如图： 4.3 重定位printf()函数​ 在main.c中的 /* USER CODE BEGIN 0 */ /* USER CODE END 0 */ 中间添加如下代码： #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&huart1, (uint8_t*)&ch, 1, HAL_MAX_DELAY); return ch; } #endif 如图所示： 添加了这段代码之后，就可以调用printf()函数进行调试打印了。 4.4 编译和清理&amp;emsp;&amp;emsp;编译可以选择菜单栏的那个锤子图标，如图： 也可以右键工程，选择编译： 然后来查看编译结果： 4.5 调试​ 这一步的前提是，ST-Link已经连上了开发板，并且开发板已经上电。 4.5.1 首先设置调试配置参数&amp;emsp;&amp;emsp;可以选择菜单栏上的小甲虫边上的向下箭头选择调试配置，如图： 也可以选择右键工程，选择Debug，然后选择调试配置，如图： 然后在弹出的这个窗口进行如下配置之后点击Apply和OK，然后就开始使用ST-Link连接芯片调试： 在过程中弹出的这个窗口可以这样选择： 这样就开始我们的调试了，至于打断点、单步调试或其他调试手段就不一一介绍了，不会的可以去百度看看。 ### 4.5.2 初体验 ​ 这一步的前提是，在调试的前提下，再把开发板上的USB口使用USB线和电脑连接起来。我们在main()函数中的USART1初始化之后，调用一个printf()看下效果，调用printf()函数还要添加一个头文件stdio.h添加代码如图： 然后编译调试，且打开串口调试工具查看： 5. 结尾​ 本篇只是新建了一个工程，还没有正式开始对VS1053B的驱动开发。下面一章就会正式开始编写VS1053B的SPI通信部分了。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"STM32","slug":"STM32","permalink":"http://slhking.github.io/tags/STM32/"},{"name":"VS1053","slug":"VS1053","permalink":"http://slhking.github.io/tags/VS1053/"}]},{"title":"VS1053B开发——手册学习笔记","date":"2021-04-11T03:52:13.000Z","path":"2021/04/11/VS1053B开发——手册学习笔记/","text":"​ 本篇是记录学习VS1053B这个芯片的手册的一些心得和笔记。 我的VS1053B开发系列所有文章 VS1053B开发——手册学习笔记 VS1053B开发——使用STM32CubeIDE新建工程。 1. VS1053是什么 这一段是翻译的官方手册 VS1053b 是单片Ogg Vorbis&#x2F;MP3&#x2F;AAC&#x2F;WMA&#x2F;MIDI音频解码器，及IMA ADPCM 编码器和用户加载的Ogg Vorbis编码器。它包含了一个高性能、有专利的低功耗DSP 处理器内核VS_DSP4、工作数据存储器、供用户应用程序和任何固化解码器一起运行的16 KiB 指令RAM 及0.5KiB 多的数据RAM、串行的控制和输入数据接口、最多8 个可用的通用I&#x2F;O引脚、一个UART、并有一个优质的可变采样率立体声ADC（“咪”、“线路”、“线路+咪”或“线路*2”）和立体声DAC、和跟随的一个耳机功放及一个公共电压缓冲器。 VS1053B通过一个串行输入总线接收它的位元流，而且它是作为一个从机来监听的。输入的数据流被解码成数字信号发给一个18bit的DAC。解码是由一个串行控制总线控制的。除了基本的解码之外，它还可以添加具有特殊功能的应用到用户RAM存储区，比如DSP效果。2. VS1053具有哪些特征 这一段是翻译的官方手册 序号 特征 序号 特征 序号 特征 1 Ogg Vorbis 解码；MPEG 1 &amp; 2 音频阶层III (CBR +VBR +ABR)；阶层 I 和 II 可选；MPEG4&#x2F;2 AAC‐LC(+PNS)，HE‐AAC V2 (级别3) (SBR + PS)；WMA 4.0&#x2F;4.1&#x2F;7&#x2F;8&#x2F;9 所有特性注1 （profiles）(5‐384kbps)；WAV (PCM + IMA ADPCM)；通用 MIDI 1 &#x2F; SP‐MIDI 格式0 的文件 9 内建PLL 时钟乘法器 17 供用户代码和数据使用的片内RAM 2 用软件插件进行Ogg Vorbis 编码（2007 第四季可用） 10 低功耗运作 18 用于控制和数据的串行接口 3 “咪&#x2F;线路”的输入信号可实现IMA ADPCM 编码 (立体声) 11 芯片内建高质量和通道间无相位误差的立体声DAC 19 可以作为从模式的辅助处理器使用 4 支持MP3 和WAV 的数据流 12 过零交叉注3（Zero‐cross）侦测和平滑的音量调整 20 特殊应用可使用SPI FLASH 存储器引导 5 EarSpeaker 空间效果注 2 处理 13 立体声耳机驱动器可以驱动一个30Ω的负载 21 可用于调试的UART 接口 6 低音和高音控制 14 安静的电源通断功能 22 可用软件增加新功能和提供最多8 个GPIO 7 只用一个单独的12..13MHz时钟运作 15 可扩展外部DAC 的I2S 接口 23 符合RoHS 无铅标准的封装（绿色环保） 8 也可以使用一个24..26MHz时钟运作 16 分离的模拟、数字、IO 供电电源 3. VS1053的结构框图 ​ 结构图的解析我们在使用到某一个部分的时候再回头添加。 4. 电气特性记录​ 作为驱动开发，大部分的电气特性只有在深入调试的时候才会关注，我个人喜欢在遇到的时候再回头看，因为一开始接触新的芯片的时候一下子肯定记不住这么多的特性。但是个人经验还是会在最初开发阶段关心下面几个参数： 4.1 推荐的操作条件 外部输入时钟XTALI的频率：12MHz~13MHz，典型值12.288MHz 内部时钟频率CLKI： 12MHz~55.3MHz，典型值36.864MHz4.1 模拟信号特性 DAC分辨率：典型值是18bit4.2 数字信号特性 SPI输入时钟频率：最大CLKI&#x2F;6，典型值6MHz SCI &amp; SDI写频率：最大CLKI&#x2F;4，典型值9MHz 所有引脚的rise time即电平拉升时间：最大50ns 5. 引脚说明 名称 引脚序号 功能 MICP&#x2F;LINE1 1 麦克风输入、自适应&#x2F;line-in 1的正极 MICN 2 麦克风输入、自适应的负极 DREQ 8 数据请求、输入总线 GPIO2&#x2F;DCLK 9 GPIO2&#x2F;串行数据输入总线的时钟线 GPIO3&#x2F;SDATA 10 GPIO3&#x2F;串行总线的数据线 GPIO6&#x2F;I2S_SCLK 11 GPIO6&#x2F;I2S的时钟线 GPIO7&#x2F;I2S_SDATA 12 GPIO7&#x2F;I2S的数据线 XDCS&#x2F;BSYNC 13 数据片选&#x2F;字节同步 XCS 23 片选输入线，低电平使能 SCLK 28 串行总线时钟线 SI 29 串行总线输入 SO 30 串行总线输出 RX 26 UART接收，没有使用的时候和IOVDD连接在一起的 TX 27 UART发送 RIGHT 39 右声道输出 GBUF 42 耳机的共同缓冲区，不能和地连接 LEFT 46 左声道输出 LINE2 48 右声道的Line-in 2 6. VS1053B的SPI​ VS1053B启动默认选择是SM_SDINEW&#x3D;1。DCLK和SDATA不会被使用，可以当作GPIO使用。BSYNC被当作片选先XCDS使用。 6.1 SPI的读 读指令Instruction[1:0]&#x3D;0b11, Instruction&#x3D;0x03 #define VS1053B_READ_CMD (0x03) 读时序： 片选使能后，主机先向VS1053发送0x03读指令，然后再发送读地址，地址只有4bit；随后VS1053向主机发送一个16bit的数据。也就是说，使能CS后，连续发送2个字节，然后读取两个字节，随后失能CS。 ## 6.2 SPI的写 写指令Instruction &#x3D; 0x02 #define VS1053B_WRITE_CMD (0x02) 写时序 片选是能后，主机想VS1053发送写指令和地址，然后开始发送16bit的数据，发送完数据后，CS失能。 7. 功能描述​ VS1053B支持许多数字信号处理功能，我们在使用某个具体的功能的时候来这里补充。 8. SCI寄存器 #define SET_REG_BITS(reg_val, bits) (reg_val |= (1&lt;&lt;bits)) #define RESET_REG_BITS(reg_val, bits) (reg_val &amp;= (~(1&lt;&lt;bits))) #define VS1053B_MODE_REG (0x00) // Mode control, Reset value 0x4800 #define VS1053B_STATUS_REG (0x01) // Status of VS1053B, Reset value 0x000C #define VS1053B_BASS_REG (0x02) // Built-in base/treble control #define VS1053B_CLOCKF_REG (0x03) // Clock freq+multiplier #define VS1053B_DECODE_T_REG (0x04) // Decode time in seconds #define VS1053B_AUDATA_REG (0x05) // Misc.audio data #define VS1053B_WRAM_REG (0x06) // RAM write or read #define VS1053B_WRAMADDR_REG (0x07) // Base addr for RAM RW #define VS1053B_HDAT0_REG (0x08) // Stream header data0, read only #define VS1053B_HDAT1_REG (0x09) // Stream header data1, read onl #define VS1053B_AIADDR_REG (0x0A) // Start addr of app #define VS1053B_VOL_REG (0x0B) // Volume control #define VS1053B_AICTRL0_REG (0x0C) // Application control reg 0 #define VS1053B_AICTRL1_REG (0x0D) // Application control reg 0 #define VS1053B_AICTRL2_REG (0x0E) // Application control reg 0 #define VS1053B_AICTRL3_REG (0x0F) // Application control reg 0 8.1 SPI_MODE(RW) 默认值0x0800， 复位值0x4800 ​ 根据此表定义SPI的模式： typedef enum { SM_DIff = 0, // Differential, 0-normal in-phase aduio; 1-left channel inverted SM_LAYER12, // Allow MPEG layers Ⅰ & Ⅱ, 0-No; 1-Yes SM_RESET, // Soft reset, 0-noreset; 1-reset SM_CANCLE, // Cancle decoding current file, 0-No; 1-Yes SM_EARSPEAKER_LO, // EarSpeaker low setting , 0-off; 1-acctive SM_TESTS, // Allow SDI Tests, 0-Not allowed; 1-allowed SM_STREAM, // Stream mode, 0-No; 1-Yes SM_EARSPEAKER_HI, // EarSpeaker high setting , 0-off; 1-acctive SM_DACT, // DCLK active edge, 0-rising; 1-falling SM_SDIORD, // SDI bit order, 0-MSB First; 1-LSB First SM_SDISHARE, // Share SPI CS, 0-No; 1-Yes SM_SDINEW, // VS1002 native SPI modes, 0-No; 1-Yes SM_ADPCM, // ADPCM recording active, 0-No; 1-Yes SM_RESERVES, // Reserved SM_LINE1, // mic/line1 selector, 0-MICP; 1-LINE1 SM_CLK_RANGE, // Input clock range, 0-12~13MHz; 1-24~26MHz }VS1053B_MODE; 例如，可以通过使用```SET_REG_BITS(value, SM_SDINEW);```来使能VS1002 New Mode。 8.2 SCI_STATUS(RW) 复位值0x000C typedef enum { SS_DO_NOT_JUMP = 15, // Header in decode, do not fast forward/rewind SS_SWING = 12, // Set swing to +0 dB, +0.5 dB, .., or +3.5 dB SS_VCM_OVERLOAD = 11, // GBUF overload indicator ’1’ = overload SS_VCM_DISABLE = 10, // GBUF overload detection ’1’ = disable SS_VER = 4, // Version SS_APDOWN2 = 3, // Analog driver powerdown SS_APDOWN1 = 2, // Analog internal powerdown SS_AD_CLOCK = 1, // AD clock select, ’0’ = 6 MHz, ’1’ = 3MHz SS_REFERENCE_SEL = 0, // Reference voltage selection, ’0’ = 1.2V, ’1’ = 1.65V }SCI_STATUS; 8.3 SCI_BASS(RW) typedef enum { ST_AMPLITUDE = 12, // Treble Control in 1.5 dB steps (-8..7, 0 = off) ST_FREQLIMIT = 8, // Lower limit frequency in 1000 Hz steps (1..15) SB_AMPLITUDE = 4, // Bass Enhancement in 1 dB steps (0..15, 0 = off) SB_FREQLIMIT = 0, // Lower limit frequency in 10 Hz steps (2..15) }SCI_BASS; 8.4 SCI_CLOCKF(RW) typedef enum { SC_MULT = 13, // Clock multiplier SC_ADD = 11, // Allowed multiplier addition SC_FREQ = 0, // Clock frequency }SCI_CLOCKF; 对于MULT和ADD的设置如下表： 默认值0表示XTAL &#x3D; 12.288MHz 由于最大采样率是XTAL&#x2F;256，所以如果XTAL&lt;12.288MHz，采样率不会有效 例如： SCI_CLOCKF = 0x9BE8 SC_MULT = 4 SC_ADD = 3 SC_FREQ = 0x3E8 = 1000 这就意味着XTAL=1000 x 4000 + 8000000 = 12MHz，始终倍频设置为3.5倍XTAL，即XTAL=3.5 * 12MHz = 42MHz，随后再加上ADD的倍频就变成了XTAL=(3.5 + 2.0) * 12MHz = 66MHz。 8.5 SCI_DECODE_TIME (RW)8.6 SCI_AUDATA (RW)8.7 SCI_WRAM (RW)8.8 SCI_WRAMADDR (W)8.9 SCI_HDAT0 和 SCI_HDAT1 (R)8.10 SCI_AIADDR (RW)8.11 SCI_VOL (RW)8.12 SCI_AICTRL[x] (RW)9. 操作9.1 时钟​ 主时钟频率12.288MHz 9.2 复位 硬件复位：XRESET引脚被拉低，芯片复位，所有的寄存器和状态被还原成初始值。硬件复位后，DREQ会保持22000个时钟周期这么长时间的低电平，也就是说，在主频12.288MHz下，复位后，隔1.8ms后芯片才会起来。 软件复位：通过设置SM_RESET位来启动软复位，然后至少等待2us再去查看DREQ。当DREQ起来后才可以继续进行常规操作。9.3 低功耗模式 通过写SCL_CLOCKF = 0x0000失能PLL来省下功耗； 将SCI_AUDATA写一个比较低的值来省功耗； 关闭所有的audio post-processing； 如果可以的话，还可以写SCI_VOL = 0xFFFF来失能模拟驱动模块；9.4 播放和解码​ 播放和解码是VS1053的基本功能。解码的是SDI的数据。解码数据被内部DAC转化成为一个模拟量。如果没有解码数据，SCI_HDAT0和SCI_HDAT1输出0。​ 当解码器没有数据输入的时候，VS1053B将处于空闲状态，直到串行总线输入了有效数据后，才会启动。9.4.1 播放整个文件​ 这是默认的重放模式。 把音频文件发送给VS1053B； 读取外部的参数值endFillByte; 发送至少2052个字节的endFillByte[7:0]，也就是发送endFillByte的低八位; 把SCI_MODE寄存器的SM_CANCEL位置1； 发送至少32个字节的endFillByte[7:0]; 读取寄存器SCI_MODE。如果SM_CANCEL仍然是置位状态则回到第5步；如果发送了2048个字节后SM_CANCEL还是没有被清零，则执行软件复位； 此时声音已经被成功的发出来了。HDAT0和HDAT1此时应该都是0以此来表明没有解码格式在进行。然后返回1； 9.4.2 取消播放​ 当用户想要从正在播放的音频切换到另一个音频的时候，取消播放就是一个常用的操作了。 将一个音频文件的一小部分发送给VS1053B； 将寄存器SCI_MODE的SM_CANCEL位置位； 持续发送那小部分的音频文件，在这个过程中，每隔32个字节读一次SM_CANCEL位。如果是置位状态，则继续本步骤；如果发送了2048个字节后或者1s后SM_CANCEL还是没有被复位，则执行软复位； 当SM_CANCEL位被复位后，读取外部参数endFillByte的值； 发送2052个字节的endfillByte[7:0]; 此时，HDAT0和HDAT1应该都被清零了，表明此时没有解码在进行，这个时候就可以发送下一个音频文件了。 9.4.3 快速播放​ VS1053支持快速播放。如果你的处理器可以快速提供足够的数据给VS1053B的话，这是一个更优的方式去快进音频。 开始传输一个音频文件给VS1053B； 要设置快速播放，就要设置外部参数playSpeed的值； 继续发送文件； 要退出快速播放模式，就将playSpeed的值写成1; 判断你的处理器是否支持这个功能，就去查看byteRate这个外部参数的值。需要注意的是，byteRate包含的播放文件的数据传输速度，即使是在快速播放模式被是能的情况下，也只是一个名义上的速度。（有点费解……后面看看从实际工程来怎么解释）; 还要注意的是，切换了音频后，播放速度是不会改变的。 9.4.4 没有音频的时候的快进可快退​ 要想快进和快退，你必须要有随机访问音频文件的能力。但是不幸的是，快进和快退不是每时每刻都能执行的，比如在读取音频文件的头部的时候就无法快进快退。 将音频文件的少部分发送给VS1053B； 当要随机访问的时候，读取寄存器SCI_STATUS的SS_DO_NOT_JUMP位。如果这一位被置位了，那么随机访问则不能进行，返回第一步； 如果SS_DO_NOT_JUMP位被复位了，就读取外部参数endFillByte的值； 发送至少2048个字节的endFillByte[7:0]； 在文件中快进或者快退； 继续发送文件； 需要注意的是： 建议快进或者快退的量以每10dB来增加或减少； 寄存器DECODE_TIME不考虑跳转； 咪头不支持随机访问。 9.5 提供PCM数据9.6 Ogg Vorbis 录音​ Ogg Vorbis简称Ogg，是一种音频压缩格式，类似于MP3，但它是完全免费的。​ MP3是有损压缩格式，因此压缩后的数据与标准CD音乐相比是有损失的。Vorbis也是有损压缩，通过使用更加先进的声学模型去减少损失。​ 因此同样位速率（BitRate）编码的OGG与MP3相比听起来会更好一些。 9.7 外部参数​ 外部参数结构体存放在X存储区，地址为0x1E00。可以读取或改变这些外部参数。芯片ID也更容易得到。 #define PARAMETRIC_VERSION 0x0003 struct parametric { /* configs are not cleared between files */ u_int32 chipID; /*1e00/01 Initialized at reset for your convenience */ u_int16 version; /*1e02 - structure version */ u_int16 config1; /*1e03 ---- ---- ppss RRRR PS mode, SBR mode, Reverb */ u_int16 playSpeed; /*1e04 0,1 = normal speed, 2 = twice, 3 = three times etc. */ u_int16 byteRate; /*1e05 average byterate */ u_int16 endFillByte; /*1e06 byte value to send after file sent */ u_int16 reserved[16]; /*1e07..15 file byte offsets */ u_int32 jumpPoints[8]; /*1e16..25 file byte offsets */ u_int16 latestJump; /*1e26 index to lastly updated jumpPoint */ u_int32 positionMsec /*1e27-28 play position, if known (WMA, Ogg Vorbis) */ s_int16 resync; /*1e29 > 0 for automatic m4a, ADIF, WMA resyncs */ 123456789101112131415161718192021222324252627282930union &#123; struct &#123; u_int32 curPacketSize; u_int32 packetSize; &#125; wma; struct &#123; u_int16 sceFoundMask; /*1e2a SCE’s found since last clear */ u_int16 cpeFoundMask; /*1e2b CPE’s found since last clear */ u_int16 lfeFoundMask; /*1e2c LFE’s found since last clear */ u_int16 playSelect; /*1e2d 0 = first any, initialized at aac init */ s_int16 dynCompress; /*1e2e -8192=1.0, initialized at aac init */ s_int16 dynBoost; /*1e2f 8192=1.0, initialized at aac init */ u_int16 sbrAndPsStatus; /*0x1e30 1=SBR, 2=upsample, 4=PS, 8=PS active */ &#125; aac; struct &#123; u_int32 bytesLeft; &#125; midi; struct &#123; s_int16 gain; /* 0x1e2a proposed gain offset in 0.5dB steps, default = -12 */ &#125; vorbis;&#125; i; }; 9.7.1 通用参数 config1：控制MIDI混响、AAC的SBR和PS的设置 playSpeed： byteRate： endFillByte：指明在SM_CANCEL之前已经发送出去的文件的字节值 jumpPoint：包含了一个32bits的偏移量。 9.8 SDI测试（SDI Test）9.9 正弦测试（Sine Test）9.10 引脚测试（PIN Test）9.11 SCI测试（SCI Test）9.12 内存测试（Mmemory Test）9.13 New Sine and Sweep Tests10. VS1053B寄存器10.1 什么情况下需要读这个章节​ 用户希望添加自己的功能的时候，比如添加DSP效果。 我们暂时不需要 11. 说明​ 本篇会随着学习的深入添加内容，逐渐完善。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"STM32","slug":"STM32","permalink":"http://slhking.github.io/tags/STM32/"},{"name":"VS1053","slug":"VS1053","permalink":"http://slhking.github.io/tags/VS1053/"}]},{"title":"土豆烧排骨","date":"2021-04-10T06:23:17.000Z","path":"2021/04/10/土豆烧排骨/","text":"​ 本篇是记录土豆少排骨这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 迷迭香美食 视频地址：简单美味的土豆炖排骨，香到骨子里！材料 序号 名称 数量 1 排骨 1匹 2 土豆 小的2-3个 3 葱姜蒜 少许 4 糖 一勺 5 胡椒粉 一小勺 6 料酒 一勺 7 生抽 一勺 8 老抽 一勺 耗时 焯水：10分钟左右 翻炒如果：5分钟左右 大火烧开：5分钟左右 小火煮：20分钟+15分钟，大约35分钟左右 总计耗时：1小时左右步骤 第一步，排骨焯水，冷水焯水，开水煮开后撇去浮沫，放入葱姜，继续焯水大概3分钟左右，捞出备用； 第二步，焯水过程中，将土豆剥皮，切成块，备用； 第三步，热锅，倒油少许，5分热的时候放入姜片和蒜片，翻炒出香味之后倒入排骨，将排骨炒至金黄色； 第四步，然后把翻炒后的排骨放到砂锅里面，加入料酒、生抽、老抽、糖、胡椒粉、一勺盐，随后加入热水，水量将恰好排骨淹没就足够了； 第五步，大火将砂锅中的水烧开，转小火煮20分钟左右； 第六步，20分钟后，把土豆倒入砂锅里，搅拌下，使其均匀受热；随后小火继续煮15分钟左右； 第七步，出锅，摆盘，将汁水淋到土豆排骨上，最后撒上一点葱花，完美；我的成果​ &#x3D;-&#x3D;没拍照经验​ 这道菜挺简单的，按照视频教的步骤一步一步做就好了~味道挺好的！","tags":[{"name":"土豆烧排骨","slug":"土豆烧排骨","permalink":"http://slhking.github.io/tags/%E5%9C%9F%E8%B1%86%E7%83%A7%E6%8E%92%E9%AA%A8/"},{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"}]},{"title":"学习做梅菜扣肉","date":"2021-04-10T05:25:13.000Z","path":"2021/04/10/学习做梅菜扣肉/","text":"​ 本篇是记录梅菜扣肉这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 黎叔教做菜 视频地址：【咸烧白】四川名菜咸烧白，你们那叫什么？材料 序号 名称 数量 1 瘦一点的五花肉 800克 2 芽菜 根据肉量定 3 豆豉 一勺 4 姜 三四片 5 葱 一根 耗时 煮五花肉：30分钟； 静置、烧开水、炸皮、泡皮、刮皮洗净：20分钟 准备芽菜：5分钟 蒸：60分钟 总共耗时：约2小时步骤 第一步，锅中接入冷水，五花肉肉朝下，皮朝上，放入水中煮，水煮开之后，把浮沫捞走，放入葱姜，继续煮20分钟左右； 第二步，20分钟后，把肉捞出来，放在那种可以漏水的盆里，把皮上煮出来的油刮掉，然后使用老抽趁热上色，最主要的是要上色均匀。上好色之后静置，放冷；在这个过程中可以同时烧一点开水备用； 第三步，锅中倒入油，热油到7、8成的时候，把五花肉的皮向下炸，炸到起皱纹的时候捞出来，一般这个过程挺快的，注意看； 第四步，捞出来后，放到一个大碗里面，用准备好的开水泡，这样是为了让皮的焦味变小，泡的时候皮要向下，泡10分钟左右； 第五步，10分钟后，把皮的皱纹刮掉，刮出金黄色，然后把五花肉清洗干净； 第六步，芽菜用清水清洗2-3次，然后热锅，锅中不需要加入油，把芽菜放到锅里面一直翻炒，直到把芽菜翻炒成一颗一颗可以散开的状态； 第七步，把炒好的芽菜盛到一个碗里面，然后加入切好的泡椒，一勺豆豉，一勺生抽，一勺料酒，7、8颗花椒，搅拌均匀； 第八步，切肉；把五花肉四边修一下，然后顺着五花肉的筋络切，厚度按照筷子的直径比较合适；通常切10片，八片摆在碗的中间，2片分别摆在两边； 第九步，把搅拌好的芽菜添加到摆好的五花肉上，把肉全部覆盖，堆叠成一个尖堆堆，然后压紧一点； 第十步，蒸；蒸锅中加入足够的水，因为要大火蒸一个小时左右；把五花肉放到蒸格上，大火蒸一个小时； 第十一步，成型；一小时后，把五花肉倒扣到另一个碗里面，梅菜扣肉出锅；我的成果 经验​ 这是我第一次做烧白，就成果而言是不合格的。总结了下以下几点没有做好的地方： 五花肉买肥了，导致烧白吃着很闷，容易腻； 切肉的时候切厚了，导致本就肥的烧白吃起来更腻了； 上色上的薄了，这个原因不太好确定，因为我在上色的时候用老抽上了好几次，但是结果还是颜色没黎叔那样好看；有可能是炸皮的时候火候大了或者炸久了，导致后面刮的时候刮掉了太多；","tags":[{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"},{"name":"梅菜扣肉","slug":"梅菜扣肉","permalink":"http://slhking.github.io/tags/%E6%A2%85%E8%8F%9C%E6%89%A3%E8%82%89/"}]},{"title":"学习计划","date":"2021-04-09T03:17:33.000Z","path":"2021/04/09/学习计划/","text":"本贴是对个人学习计划的规划贴。 计划表 学习内容 开始时间 预计周期 Hexo指令 2021-4-2 持续 Linux学习 2021-4-2 持续 Linux SocketCAN学习 2021-4-8 两个月 freeRTOS学习 2021-4-9 一个月 Linux SocketCAN学习进度表 时间 Linux SocketCAN进度 内容 \\ \\ \\ freeRTOS学习进度表 时间 freeRTOS学习 内容 \\ \\ \\","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Hexo指令","date":"2021-04-04T09:36:50.000Z","path":"2021/04/04/Hexo指令/","text":"说明：本文档作为Hexo新手学习笔记文档，遇到新命令即记录，不定时更新ing。 1. 发布文章1. hexo new [layout] &lt;title&gt; 新建一篇文章，如果没有使用layout的话，默认使用_config.yml中的default_layout代替。如果title含空格，使用双引号括起来： hexo new &quot;my test&quot; 参数： 参数 描述 –p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 文章的属性： 设置 描述 默认 layout Layout post或者page title 文章的标题 文章的文件名 data 创建日期 文件建立日期 updated 修改日期 文件更新日期 comments 是否开启评论 trus tags 标签 categories 分类 permalink 覆盖文章网址 文件名 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 新建草稿： hexo new draft &quot;草稿&quot; 发布草稿： hexo publish &quot;草稿&quot; 给文章添加分类和标签： 1234567categories:- 分类- 子分类- 子子分类tags:- 标签1- 标签2","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]