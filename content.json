[{"title":"VS1053B开发——使用STM32CubeIDE新建工程","date":"2021-04-11T15:46:42.000Z","path":"2021/04/11/VS1053B开发——使用STM32CubeIDE新建工程/","text":"​ 本篇是记录的是使用STM32CubeIDE新建一个开发VS1053B芯片的工程，包括了对基本外设的配置和FATFS系统以及freeRTOS系统的添加。 我的VS1053B开发系列所有文章 VS1053B开发——手册学习笔记 VS1053B开发——使用STM32CubeIDE新建工程。 源码地址 新建工程源码：VS1053B_Prj_NewProject 使用命令 git clone https://gitee.com/slhking/vs1053-b_-prj_-new-project.git将工程下载到本地。 1. 开发环境 硬件环境：STM32F103 + VS1053B + 咪头 + 运放喇叭 软件环境：STM32CubeIDE 串口调试工具：Mobaxterm 其他工具：需要SD卡，因为使用了FATFS来读取SD卡内的MP3文件 预先使用这些，后面使用到了再来添加 2. 硬件框图3. 程序流程图4. 建立工程 使用HAL库； MCU主频72MHz； 使用freeFTOS; 使用FATFS； 4.1 使用STM32CubeIDE创建基础工程 第一步，创建工程文件夹：在保存项目工程的路径下新建项目文件夹，我的就取名叫VS1053B_Prj，如图： 第二步，打开STM32CubeIDE，选择工作区路径，我们就选择在项目文件夹下，然后点击Launch，如图: 第三步，新建STM32工程，如图： 第四步，选择芯片，首先搜索我们使用的芯片，然后根据封装选择具体是哪一个，随后点击Next，如图： 第五步，设置工程名称及模板，首先给工程取一个名字，我们就和项目名称一样，然后操作条件即工程模板就使用默认参数，随后点击Finish，在弹出来的框体中选择Yes，如图： 第六步，初始化系统时钟，我习惯上先初始化系统时钟，选择外部晶振，随后去配置PLL时钟源来自HSE，系统时钟源来自PLLCLK，主频设置为72MHz，然后敲击回车让STM32CubeMX自动得到时钟方案，如图： 第七步，设置Debug，默认是不使能Debug功能，但是我们开发过程中肯定会使用到Debug功能的，因而这里随意选择一种都可以，如图： 第八步，配置SDIO，选择SD 4 bits Wide Bus，然后其他参数默认就好，如图： 第九步，配置FATFS。我们需要FATFS文件系统来读取SD卡内的MP3文件，所以需要添加FATFS。模式选择SD Card，参数使用默认参数，如图： 第十步，配置MCU和VS1053B之间通信使用的SPI，我们首先查看原理图，使用的是哪几个引脚以及使用的是哪一个SPI，原理图如图： ​ 可以看到，使用的是MCU的SPI2，引脚是: 引脚号 SPI 线 功能描述 PB12 SPI2_CS0 硬件片选 PB13 SPI2_SCK SPI时钟线 PB14 SPI2_MISO SPI主机接收从机输出 PB15 SPI2_MOSI SPI主机输出从机输入 所以我们来配置SPI2的参数，首先选择全双工主机模式，然后是硬件片选，随后是分频倍数，因为在上一篇我们知道，在配置VS1053的时候VS1053B的SPI频率在外部晶振是12.288MHz时最大是6MHz，读写RAM的时候最大是9MHz，所以我们在初始化的时候选择8分频。即36MHz&#x2F;8&#x3D;4.5MHz，其他的先暂时使用默认值，如图： - 第十一步，配置USART1，原理图上使用的引脚是PA9和PA10，如图： 所以我们在STM32CubeMX里来配置USART1，首先选择USART1，模式选择异步通信，波特率设置为115200，数据位是8bit，没有校验位，1bit的停止位，全双工模式，如图： - 第十二步，配置freeFTOS，接口那里选择V1或者V2都可以，我选择的是V2（对freeRTOS的了解还不深，解释不了为什么，到后面学习freeRTOS后再来天坑），其他参数使用默认值，如图： - 第十三步，设置工程参数，主要是设置一个给配置的外设添加对应的.c和.h文件，如图所示： - 第十四步，保存STM32CubeMX的配置，键盘按Ctrl + S，然后生成代码，然后在过程中弹出来的窗口都选择Yes就好了，如图： 4.2 观察生成的工程​ STM32CubeIDE下使用STM32CubeMX生成的代码，其结构和IDE各窗口如图所示： 因为使用了STM32CubeMX，而且在可见的未来，我们后续还会使用CubeMX来配置某些外设，因而在编辑代码的时候就要遵循一个规则，即在USER CODE BEGIN和USER CODE END之间添加我们想要添加的代码，这样是为了避免下次使用CubeMX配置别的外设的时候，重新生成代码时，我们在这个区域外添加的代码被覆盖消失掉，如图： 4.3 重定位printf()函数​ 在main.c中的 /* USER CODE BEGIN 0 */ /* USER CODE END 0 */ 中间添加如下代码： #ifdef __GNUC__ #define PUTCHAR_PROTOTYPE int __io_putchar(int ch) PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&huart1, (uint8_t*)&ch, 1, HAL_MAX_DELAY); return ch; } #endif 如图所示： 添加了这段代码之后，就可以调用printf()函数进行调试打印了。 4.4 编译和清理&amp;emsp;&amp;emsp;编译可以选择菜单栏的那个锤子图标，如图： 也可以右键工程，选择编译： 然后来查看编译结果： 4.5 调试​ 这一步的前提是，ST-Link已经连上了开发板，并且开发板已经上电。 4.5.1 首先设置调试配置参数&amp;emsp;&amp;emsp;可以选择菜单栏上的小甲虫边上的向下箭头选择调试配置，如图： 也可以选择右键工程，选择Debug，然后选择调试配置，如图： 然后在弹出的这个窗口进行如下配置之后点击Apply和OK，然后就开始使用ST-Link连接芯片调试： 在过程中弹出的这个窗口可以这样选择： 这样就开始我们的调试了，至于打断点、单步调试或其他调试手段就不一一介绍了，不会的可以去百度看看。 ### 4.5.2 初体验 ​ 这一步的前提是，在调试的前提下，再把开发板上的USB口使用USB线和电脑连接起来。我们在main()函数中的USART1初始化之后，调用一个printf()看下效果，调用printf()函数还要添加一个头文件stdio.h添加代码如图： 然后编译调试，且打开串口调试工具查看： 5. 结尾​ 本篇只是新建了一个工程，还没有正式开始对VS1053B的驱动开发。下面一章就会正式开始编写VS1053B的SPI通信部分了。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"STM32","slug":"STM32","permalink":"http://slhking.github.io/tags/STM32/"},{"name":"VS1053","slug":"VS1053","permalink":"http://slhking.github.io/tags/VS1053/"}]},{"title":"VS1053B开发——手册学习笔记","date":"2021-04-11T03:52:13.000Z","path":"2021/04/11/VS1053B开发——手册学习笔记/","text":"​ 本篇是记录学习VS1053B这个芯片的手册的一些心得和笔记。 我的VS1053B开发系列所有文章 VS1053B开发——手册学习笔记 VS1053B开发——使用STM32CubeIDE新建工程。 1. VS1053是什么 这一段是翻译的官方手册 VS1053b 是单片Ogg Vorbis&#x2F;MP3&#x2F;AAC&#x2F;WMA&#x2F;MIDI音频解码器，及IMA ADPCM 编码器和用户加载的Ogg Vorbis编码器。它包含了一个高性能、有专利的低功耗DSP 处理器内核VS_DSP4、工作数据存储器、供用户应用程序和任何固化解码器一起运行的16 KiB 指令RAM 及0.5KiB 多的数据RAM、串行的控制和输入数据接口、最多8 个可用的通用I&#x2F;O引脚、一个UART、并有一个优质的可变采样率立体声ADC（“咪”、“线路”、“线路+咪”或“线路*2”）和立体声DAC、和跟随的一个耳机功放及一个公共电压缓冲器。 VS1053B通过一个串行输入总线接收它的位元流，而且它是作为一个从机来监听的。输入的数据流被解码成数字信号发给一个18bit的DAC。解码是由一个串行控制总线控制的。除了基本的解码之外，它还可以添加具有特殊功能的应用到用户RAM存储区，比如DSP效果。2. VS1053具有哪些特征 这一段是翻译的官方手册 序号 特征 序号 特征 序号 特征 1 Ogg Vorbis 解码；MPEG 1 &amp; 2 音频阶层III (CBR +VBR +ABR)；阶层 I 和 II 可选；MPEG4&#x2F;2 AAC‐LC(+PNS)，HE‐AAC V2 (级别3) (SBR + PS)；WMA 4.0&#x2F;4.1&#x2F;7&#x2F;8&#x2F;9 所有特性注1 （profiles）(5‐384kbps)；WAV (PCM + IMA ADPCM)；通用 MIDI 1 &#x2F; SP‐MIDI 格式0 的文件 9 内建PLL 时钟乘法器 17 供用户代码和数据使用的片内RAM 2 用软件插件进行Ogg Vorbis 编码（2007 第四季可用） 10 低功耗运作 18 用于控制和数据的串行接口 3 “咪&#x2F;线路”的输入信号可实现IMA ADPCM 编码 (立体声) 11 芯片内建高质量和通道间无相位误差的立体声DAC 19 可以作为从模式的辅助处理器使用 4 支持MP3 和WAV 的数据流 12 过零交叉注3（Zero‐cross）侦测和平滑的音量调整 20 特殊应用可使用SPI FLASH 存储器引导 5 EarSpeaker 空间效果注 2 处理 13 立体声耳机驱动器可以驱动一个30Ω的负载 21 可用于调试的UART 接口 6 低音和高音控制 14 安静的电源通断功能 22 可用软件增加新功能和提供最多8 个GPIO 7 只用一个单独的12..13MHz时钟运作 15 可扩展外部DAC 的I2S 接口 23 符合RoHS 无铅标准的封装（绿色环保） 8 也可以使用一个24..26MHz时钟运作 16 分离的模拟、数字、IO 供电电源 3. VS1053的结构框图 ​ 结构图的解析我们在使用到某一个部分的时候再回头添加。 4. 电气特性记录​ 作为驱动开发，大部分的电气特性只有在深入调试的时候才会关注，我个人喜欢在遇到的时候再回头看，因为一开始接触新的芯片的时候一下子肯定记不住这么多的特性。但是个人经验还是会在最初开发阶段关心下面几个参数： 4.1 推荐的操作条件 外部输入时钟XTALI的频率：12MHz~13MHz，典型值12.288MHz 内部时钟频率CLKI： 12MHz~55.3MHz，典型值36.864MHz4.1 模拟信号特性 DAC分辨率：典型值是18bit4.2 数字信号特性 SPI输入时钟频率：最大CLKI&#x2F;6，典型值6MHz SCI &amp; SDI写频率：最大CLKI&#x2F;4，典型值9MHz 所有引脚的rise time即电平拉升时间：最大50ns 5. 引脚说明 名称 引脚序号 功能 MICP&#x2F;LINE1 1 麦克风输入、自适应&#x2F;line-in 1的正极 MICN 2 麦克风输入、自适应的负极 DREQ 8 数据请求、输入总线 GPIO2&#x2F;DCLK 9 GPIO2&#x2F;串行数据输入总线的时钟线 GPIO3&#x2F;SDATA 10 GPIO3&#x2F;串行总线的数据线 GPIO6&#x2F;I2S_SCLK 11 GPIO6&#x2F;I2S的时钟线 GPIO7&#x2F;I2S_SDATA 12 GPIO7&#x2F;I2S的数据线 XDCS&#x2F;BSYNC 13 数据片选&#x2F;字节同步 XCS 23 片选输入线，低电平使能 SCLK 28 串行总线时钟线 SI 29 串行总线输入 SO 30 串行总线输出 RX 26 UART接收，没有使用的时候和IOVDD连接在一起的 TX 27 UART发送 RIGHT 39 右声道输出 GBUF 42 耳机的共同缓冲区，不能和地连接 LEFT 46 左声道输出 LINE2 48 右声道的Line-in 2 6. VS1053B的SPI​ VS1053B启动默认选择是SM_SDINEW&#x3D;1。DCLK和SDATA不会被使用，可以当作GPIO使用。BSYNC被当作片选先XCDS使用。 6.1 SPI的读 读指令Instruction[1:0]&#x3D;0b11, Instruction&#x3D;0x03 #define VS1053B_READ_CMD (0x03) 读时序： 片选使能后，主机先向VS1053发送0x03读指令，然后再发送读地址，地址只有4bit；随后VS1053向主机发送一个16bit的数据。也就是说，使能CS后，连续发送2个字节，然后读取两个字节，随后失能CS。 ## 6.2 SPI的写 写指令Instruction &#x3D; 0x02 #define VS1053B_WRITE_CMD (0x02) 写时序 片选是能后，主机想VS1053发送写指令和地址，然后开始发送16bit的数据，发送完数据后，CS失能。 7. 功能描述​ VS1053B支持许多数字信号处理功能，我们在使用某个具体的功能的时候来这里补充。 8. SCI寄存器 #define SET_REG_BITS(reg_val, bits) (reg_val |= (1&lt;&lt;bits)) #define RESET_REG_BITS(reg_val, bits) (reg_val &amp;= (~(1&lt;&lt;bits))) #define VS1053B_MODE_REG (0x00) // Mode control, Reset value 0x4800 #define VS1053B_STATUS_REG (0x01) // Status of VS1053B, Reset value 0x000C #define VS1053B_BASS_REG (0x02) // Built-in base/treble control #define VS1053B_CLOCKF_REG (0x03) // Clock freq+multiplier #define VS1053B_DECODE_T_REG (0x04) // Decode time in seconds #define VS1053B_AUDATA_REG (0x05) // Misc.audio data #define VS1053B_WRAM_REG (0x06) // RAM write or read #define VS1053B_WRAMADDR_REG (0x07) // Base addr for RAM RW #define VS1053B_HDAT0_REG (0x08) // Stream header data0, read only #define VS1053B_HDAT1_REG (0x09) // Stream header data1, read onl #define VS1053B_AIADDR_REG (0x0A) // Start addr of app #define VS1053B_VOL_REG (0x0B) // Volume control #define VS1053B_AICTRL0_REG (0x0C) // Application control reg 0 #define VS1053B_AICTRL1_REG (0x0D) // Application control reg 0 #define VS1053B_AICTRL2_REG (0x0E) // Application control reg 0 #define VS1053B_AICTRL3_REG (0x0F) // Application control reg 0 8.1 SPI_MODE(RW) 默认值0x0800， 复位值0x4800 ​ 根据此表定义SPI的模式： typedef enum { SM_DIff = 0, // Differential, 0-normal in-phase aduio; 1-left channel inverted SM_LAYER12, // Allow MPEG layers Ⅰ & Ⅱ, 0-No; 1-Yes SM_RESET, // Soft reset, 0-noreset; 1-reset SM_CANCLE, // Cancle decoding current file, 0-No; 1-Yes SM_EARSPEAKER_LO, // EarSpeaker low setting , 0-off; 1-acctive SM_TESTS, // Allow SDI Tests, 0-Not allowed; 1-allowed SM_STREAM, // Stream mode, 0-No; 1-Yes SM_EARSPEAKER_HI, // EarSpeaker high setting , 0-off; 1-acctive SM_DACT, // DCLK active edge, 0-rising; 1-falling SM_SDIORD, // SDI bit order, 0-MSB First; 1-LSB First SM_SDISHARE, // Share SPI CS, 0-No; 1-Yes SM_SDINEW, // VS1002 native SPI modes, 0-No; 1-Yes SM_ADPCM, // ADPCM recording active, 0-No; 1-Yes SM_RESERVES, // Reserved SM_LINE1, // mic/line1 selector, 0-MICP; 1-LINE1 SM_CLK_RANGE, // Input clock range, 0-12~13MHz; 1-24~26MHz }VS1053B_MODE; 例如，可以通过使用```SET_REG_BITS(value, SM_SDINEW);```来使能VS1002 New Mode。 8.2 SCI_STATUS(RW) 复位值0x000C typedef enum { SS_DO_NOT_JUMP = 15, // Header in decode, do not fast forward/rewind SS_SWING = 12, // Set swing to +0 dB, +0.5 dB, .., or +3.5 dB SS_VCM_OVERLOAD = 11, // GBUF overload indicator ’1’ = overload SS_VCM_DISABLE = 10, // GBUF overload detection ’1’ = disable SS_VER = 4, // Version SS_APDOWN2 = 3, // Analog driver powerdown SS_APDOWN1 = 2, // Analog internal powerdown SS_AD_CLOCK = 1, // AD clock select, ’0’ = 6 MHz, ’1’ = 3MHz SS_REFERENCE_SEL = 0, // Reference voltage selection, ’0’ = 1.2V, ’1’ = 1.65V }SCI_STATUS; 8.3 SCI_BASS(RW) typedef enum { ST_AMPLITUDE = 12, // Treble Control in 1.5 dB steps (-8..7, 0 = off) ST_FREQLIMIT = 8, // Lower limit frequency in 1000 Hz steps (1..15) SB_AMPLITUDE = 4, // Bass Enhancement in 1 dB steps (0..15, 0 = off) SB_FREQLIMIT = 0, // Lower limit frequency in 10 Hz steps (2..15) }SCI_BASS; 8.4 SCI_CLOCKF(RW) typedef enum { SC_MULT = 13, // Clock multiplier SC_ADD = 11, // Allowed multiplier addition SC_FREQ = 0, // Clock frequency }SCI_CLOCKF; 对于MULT和ADD的设置如下表： 默认值0表示XTAL &#x3D; 12.288MHz 由于最大采样率是XTAL&#x2F;256，所以如果XTAL&lt;12.288MHz，采样率不会有效 例如： SCI_CLOCKF = 0x9BE8 SC_MULT = 4 SC_ADD = 3 SC_FREQ = 0x3E8 = 1000 这就意味着XTAL=1000 x 4000 + 8000000 = 12MHz，始终倍频设置为3.5倍XTAL，即XTAL=3.5 * 12MHz = 42MHz，随后再加上ADD的倍频就变成了XTAL=(3.5 + 2.0) * 12MHz = 66MHz。 8.5 SCI_DECODE_TIME (RW)8.6 SCI_AUDATA (RW)8.7 SCI_WRAM (RW)8.8 SCI_WRAMADDR (W)8.9 SCI_HDAT0 和 SCI_HDAT1 (R)8.10 SCI_AIADDR (RW)8.11 SCI_VOL (RW)8.12 SCI_AICTRL[x] (RW)9. 操作9.1 时钟​ 主时钟频率12.288MHz 9.2 复位 硬件复位：XRESET引脚被拉低，芯片复位，所有的寄存器和状态被还原成初始值。硬件复位后，DREQ会保持22000个时钟周期这么长时间的低电平，也就是说，在主频12.288MHz下，复位后，隔1.8ms后芯片才会起来。 软件复位：通过设置SM_RESET位来启动软复位，然后至少等待2us再去查看DREQ。当DREQ起来后才可以继续进行常规操作。9.3 低功耗模式 通过写SCL_CLOCKF = 0x0000失能PLL来省下功耗； 将SCI_AUDATA写一个比较低的值来省功耗； 关闭所有的audio post-processing； 如果可以的话，还可以写SCI_VOL = 0xFFFF来失能模拟驱动模块；9.4 播放和解码​ 播放和解码是VS1053的基本功能。解码的是SDI的数据。解码数据被内部DAC转化成为一个模拟量。如果没有解码数据，SCI_HDAT0和SCI_HDAT1输出0。​ 当解码器没有数据输入的时候，VS1053B将处于空闲状态，直到串行总线输入了有效数据后，才会启动。9.4.1 播放整个文件​ 这是默认的重放模式。 把音频文件发送给VS1053B； 读取外部的参数值endFillByte; 发送至少2052个字节的endFillByte[7:0]，也就是发送endFillByte的低八位; 把SCI_MODE寄存器的SM_CANCEL位置1； 发送至少32个字节的endFillByte[7:0]; 读取寄存器SCI_MODE。如果SM_CANCEL仍然是置位状态则回到第5步；如果发送了2048个字节后SM_CANCEL还是没有被清零，则执行软件复位； 此时声音已经被成功的发出来了。HDAT0和HDAT1此时应该都是0以此来表明没有解码格式在进行。然后返回1； 9.4.2 取消播放​ 当用户想要从正在播放的音频切换到另一个音频的时候，取消播放就是一个常用的操作了。 将一个音频文件的一小部分发送给VS1053B； 将寄存器SCI_MODE的SM_CANCEL位置位； 持续发送那小部分的音频文件，在这个过程中，每隔32个字节读一次SM_CANCEL位。如果是置位状态，则继续本步骤；如果发送了2048个字节后或者1s后SM_CANCEL还是没有被复位，则执行软复位； 当SM_CANCEL位被复位后，读取外部参数endFillByte的值； 发送2052个字节的endfillByte[7:0]; 此时，HDAT0和HDAT1应该都被清零了，表明此时没有解码在进行，这个时候就可以发送下一个音频文件了。 9.4.3 快速播放​ VS1053支持快速播放。如果你的处理器可以快速提供足够的数据给VS1053B的话，这是一个更优的方式去快进音频。 开始传输一个音频文件给VS1053B； 要设置快速播放，就要设置外部参数playSpeed的值； 继续发送文件； 要退出快速播放模式，就将playSpeed的值写成1; 判断你的处理器是否支持这个功能，就去查看byteRate这个外部参数的值。需要注意的是，byteRate包含的播放文件的数据传输速度，即使是在快速播放模式被是能的情况下，也只是一个名义上的速度。（有点费解……后面看看从实际工程来怎么解释）; 还要注意的是，切换了音频后，播放速度是不会改变的。 9.4.4 没有音频的时候的快进可快退​ 要想快进和快退，你必须要有随机访问音频文件的能力。但是不幸的是，快进和快退不是每时每刻都能执行的，比如在读取音频文件的头部的时候就无法快进快退。 将音频文件的少部分发送给VS1053B； 当要随机访问的时候，读取寄存器SCI_STATUS的SS_DO_NOT_JUMP位。如果这一位被置位了，那么随机访问则不能进行，返回第一步； 如果SS_DO_NOT_JUMP位被复位了，就读取外部参数endFillByte的值； 发送至少2048个字节的endFillByte[7:0]； 在文件中快进或者快退； 继续发送文件； 需要注意的是： 建议快进或者快退的量以每10dB来增加或减少； 寄存器DECODE_TIME不考虑跳转； 咪头不支持随机访问。 9.5 提供PCM数据9.6 Ogg Vorbis 录音​ Ogg Vorbis简称Ogg，是一种音频压缩格式，类似于MP3，但它是完全免费的。​ MP3是有损压缩格式，因此压缩后的数据与标准CD音乐相比是有损失的。Vorbis也是有损压缩，通过使用更加先进的声学模型去减少损失。​ 因此同样位速率（BitRate）编码的OGG与MP3相比听起来会更好一些。 9.7 外部参数​ 外部参数结构体存放在X存储区，地址为0x1E00。可以读取或改变这些外部参数。芯片ID也更容易得到。 #define PARAMETRIC_VERSION 0x0003 struct parametric { /* configs are not cleared between files */ u_int32 chipID; /*1e00/01 Initialized at reset for your convenience */ u_int16 version; /*1e02 - structure version */ u_int16 config1; /*1e03 ---- ---- ppss RRRR PS mode, SBR mode, Reverb */ u_int16 playSpeed; /*1e04 0,1 = normal speed, 2 = twice, 3 = three times etc. */ u_int16 byteRate; /*1e05 average byterate */ u_int16 endFillByte; /*1e06 byte value to send after file sent */ u_int16 reserved[16]; /*1e07..15 file byte offsets */ u_int32 jumpPoints[8]; /*1e16..25 file byte offsets */ u_int16 latestJump; /*1e26 index to lastly updated jumpPoint */ u_int32 positionMsec /*1e27-28 play position, if known (WMA, Ogg Vorbis) */ s_int16 resync; /*1e29 > 0 for automatic m4a, ADIF, WMA resyncs */ 123456789101112131415161718192021222324252627282930union &#123; struct &#123; u_int32 curPacketSize; u_int32 packetSize; &#125; wma; struct &#123; u_int16 sceFoundMask; /*1e2a SCE’s found since last clear */ u_int16 cpeFoundMask; /*1e2b CPE’s found since last clear */ u_int16 lfeFoundMask; /*1e2c LFE’s found since last clear */ u_int16 playSelect; /*1e2d 0 = first any, initialized at aac init */ s_int16 dynCompress; /*1e2e -8192=1.0, initialized at aac init */ s_int16 dynBoost; /*1e2f 8192=1.0, initialized at aac init */ u_int16 sbrAndPsStatus; /*0x1e30 1=SBR, 2=upsample, 4=PS, 8=PS active */ &#125; aac; struct &#123; u_int32 bytesLeft; &#125; midi; struct &#123; s_int16 gain; /* 0x1e2a proposed gain offset in 0.5dB steps, default = -12 */ &#125; vorbis;&#125; i; }; 9.7.1 通用参数 config1：控制MIDI混响、AAC的SBR和PS的设置 playSpeed： byteRate： endFillByte：指明在SM_CANCEL之前已经发送出去的文件的字节值 jumpPoint：包含了一个32bits的偏移量。 9.8 SDI测试（SDI Test）9.9 正弦测试（Sine Test）9.10 引脚测试（PIN Test）9.11 SCI测试（SCI Test）9.12 内存测试（Mmemory Test）9.13 New Sine and Sweep Tests10. VS1053B寄存器10.1 什么情况下需要读这个章节​ 用户希望添加自己的功能的时候，比如添加DSP效果。 我们暂时不需要 11. 说明​ 本篇会随着学习的深入添加内容，逐渐完善。","tags":[{"name":"mcu","slug":"mcu","permalink":"http://slhking.github.io/tags/mcu/"},{"name":"STM32","slug":"STM32","permalink":"http://slhking.github.io/tags/STM32/"},{"name":"VS1053","slug":"VS1053","permalink":"http://slhking.github.io/tags/VS1053/"}]},{"title":"土豆烧排骨","date":"2021-04-10T06:23:17.000Z","path":"2021/04/10/土豆烧排骨/","text":"​ 本篇是记录土豆少排骨这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 迷迭香美食 视频地址：简单美味的土豆炖排骨，香到骨子里！材料 序号 名称 数量 1 排骨 1匹 2 土豆 小的2-3个 3 葱姜蒜 少许 4 糖 一勺 5 胡椒粉 一小勺 6 料酒 一勺 7 生抽 一勺 8 老抽 一勺 耗时 焯水：10分钟左右 翻炒如果：5分钟左右 大火烧开：5分钟左右 小火煮：20分钟+15分钟，大约35分钟左右 总计耗时：1小时左右步骤 第一步，排骨焯水，冷水焯水，开水煮开后撇去浮沫，放入葱姜，继续焯水大概3分钟左右，捞出备用； 第二步，焯水过程中，将土豆剥皮，切成块，备用； 第三步，热锅，倒油少许，5分热的时候放入姜片和蒜片，翻炒出香味之后倒入排骨，将排骨炒至金黄色； 第四步，然后把翻炒后的排骨放到砂锅里面，加入料酒、生抽、老抽、糖、胡椒粉、一勺盐，随后加入热水，水量将恰好排骨淹没就足够了； 第五步，大火将砂锅中的水烧开，转小火煮20分钟左右； 第六步，20分钟后，把土豆倒入砂锅里，搅拌下，使其均匀受热；随后小火继续煮15分钟左右； 第七步，出锅，摆盘，将汁水淋到土豆排骨上，最后撒上一点葱花，完美；我的成果​ &#x3D;-&#x3D;没拍照经验​ 这道菜挺简单的，按照视频教的步骤一步一步做就好了~味道挺好的！","tags":[{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"},{"name":"土豆烧排骨","slug":"土豆烧排骨","permalink":"http://slhking.github.io/tags/%E5%9C%9F%E8%B1%86%E7%83%A7%E6%8E%92%E9%AA%A8/"}]},{"title":"学习做梅菜扣肉","date":"2021-04-10T05:25:13.000Z","path":"2021/04/10/学习做梅菜扣肉/","text":"​ 本篇是记录梅菜扣肉这道菜第一次学习烹饪的过程以及总结。 教学老师： 哔哩哔哩Up主： 黎叔教做菜 视频地址：【咸烧白】四川名菜咸烧白，你们那叫什么？材料 序号 名称 数量 1 瘦一点的五花肉 800克 2 芽菜 根据肉量定 3 豆豉 一勺 4 姜 三四片 5 葱 一根 耗时 煮五花肉：30分钟； 静置、烧开水、炸皮、泡皮、刮皮洗净：20分钟 准备芽菜：5分钟 蒸：60分钟 总共耗时：约2小时步骤 第一步，锅中接入冷水，五花肉肉朝下，皮朝上，放入水中煮，水煮开之后，把浮沫捞走，放入葱姜，继续煮20分钟左右； 第二步，20分钟后，把肉捞出来，放在那种可以漏水的盆里，把皮上煮出来的油刮掉，然后使用老抽趁热上色，最主要的是要上色均匀。上好色之后静置，放冷；在这个过程中可以同时烧一点开水备用； 第三步，锅中倒入油，热油到7、8成的时候，把五花肉的皮向下炸，炸到起皱纹的时候捞出来，一般这个过程挺快的，注意看； 第四步，捞出来后，放到一个大碗里面，用准备好的开水泡，这样是为了让皮的焦味变小，泡的时候皮要向下，泡10分钟左右； 第五步，10分钟后，把皮的皱纹刮掉，刮出金黄色，然后把五花肉清洗干净； 第六步，芽菜用清水清洗2-3次，然后热锅，锅中不需要加入油，把芽菜放到锅里面一直翻炒，直到把芽菜翻炒成一颗一颗可以散开的状态； 第七步，把炒好的芽菜盛到一个碗里面，然后加入切好的泡椒，一勺豆豉，一勺生抽，一勺料酒，7、8颗花椒，搅拌均匀； 第八步，切肉；把五花肉四边修一下，然后顺着五花肉的筋络切，厚度按照筷子的直径比较合适；通常切10片，八片摆在碗的中间，2片分别摆在两边； 第九步，把搅拌好的芽菜添加到摆好的五花肉上，把肉全部覆盖，堆叠成一个尖堆堆，然后压紧一点； 第十步，蒸；蒸锅中加入足够的水，因为要大火蒸一个小时左右；把五花肉放到蒸格上，大火蒸一个小时； 第十一步，成型；一小时后，把五花肉倒扣到另一个碗里面，梅菜扣肉出锅；我的成果 经验​ 这是我第一次做烧白，就成果而言是不合格的。总结了下以下几点没有做好的地方： 五花肉买肥了，导致烧白吃着很闷，容易腻； 切肉的时候切厚了，导致本就肥的烧白吃起来更腻了； 上色上的薄了，这个原因不太好确定，因为我在上色的时候用老抽上了好几次，但是结果还是颜色没黎叔那样好看；有可能是炸皮的时候火候大了或者炸久了，导致后面刮的时候刮掉了太多；","tags":[{"name":"梅菜扣肉","slug":"梅菜扣肉","permalink":"http://slhking.github.io/tags/%E6%A2%85%E8%8F%9C%E6%89%A3%E8%82%89/"},{"name":"美食","slug":"美食","permalink":"http://slhking.github.io/tags/%E7%BE%8E%E9%A3%9F/"}]},{"title":"学习计划","date":"2021-04-09T03:17:33.000Z","path":"2021/04/09/学习计划/","text":"本贴是对个人学习计划的规划贴。 计划表 学习内容 开始时间 预计周期 Hexo指令 2021-4-2 持续 Linux学习 2021-4-2 持续 Linux SocketCAN学习 2021-4-8 两个月 freeRTOS学习 2021-4-9 一个月 Linux SocketCAN学习进度表 时间 Linux SocketCAN进度 内容 \\ \\ \\ freeRTOS学习进度表 时间 freeRTOS学习 内容 \\ \\ \\","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"Hexo指令","date":"2021-04-04T09:36:50.000Z","path":"2021/04/04/Hexo指令/","text":"说明：本文档作为Hexo新手学习笔记文档，遇到新命令即记录，不定时更新ing。 1. 发布文章1. hexo new [layout] &lt;title&gt; 新建一篇文章，如果没有使用layout的话，默认使用_config.yml中的default_layout代替。如果title含空格，使用双引号括起来： hexo new &quot;my test&quot; 参数： 参数 描述 –p, –path 自定义新文章的路径 -r, –replace 如果存在同名文章，将其替换 -s, –slug 文章的 Slug，作为新文章的文件名和发布后的 URL 文章的属性： 设置 描述 默认 layout Layout post或者page title 文章的标题 文章的文件名 data 创建日期 文件建立日期 updated 修改日期 文件更新日期 comments 是否开启评论 trus tags 标签 categories 分类 permalink 覆盖文章网址 文件名 keywords 仅用于 meta 标签和 Open Graph 的关键词（不推荐使用） 新建草稿： hexo new draft &quot;草稿&quot; 发布草稿： hexo publish &quot;草稿&quot; 给文章添加分类和标签： 1234567categories:- 分类- 子分类- 子子分类tags:- 标签1- 标签2","tags":[{"name":"随笔","slug":"随笔","permalink":"http://slhking.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]